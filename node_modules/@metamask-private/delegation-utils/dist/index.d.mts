export * from '@metamask-private/delegation-deployments';
export * from '@metamask-private/delegation-abis';
import * as viem from 'viem';
import { Hex, AbiFunction, TypedData, AbiParameter, WalletClient, Transport, Chain, Account, Address, Abi, TypedDataDefinition, PublicClient } from 'viem';

declare const CAVEAT_ABI_TYPE_COMPONENTS: {
    type: string;
    name: string;
}[];
type CaveatStruct = {
    enforcer: Hex;
    terms: Hex;
    args: Hex;
};
declare const CAVEAT_TYPEHASH: Hex;
declare const getCaveatArrayPacketHash: (input: CaveatStruct[]) => Hex;
declare const getCaveatPacketHash: (input: CaveatStruct) => Hex;
declare const createCaveat: (enforcer: Hex, terms: Hex, args?: Hex) => CaveatStruct;

type MethodSelector = Hex | string | AbiFunction;

type Caveats = CaveatBuilder | CaveatStruct[];
declare const resolveCaveats: (caveats: Caveats) => CaveatStruct[];
type RemoveFirst<T extends any[]> = T extends [any, ...infer Rest] ? Rest : never;
type CaveatBuilderMap = {
    [key: string]: (environment: DeleGatorEnvironment, ...args: [...any]) => CaveatStruct;
};
type CaveatBuilderConfig = {
    allowEmptyCaveats?: boolean;
};
declare class CaveatBuilder<TCaveatBuilderMap extends CaveatBuilderMap = {}> {
    private readonly environment;
    private readonly config;
    private readonly enforcerBuilders;
    private results;
    private hasBeenBuilt;
    constructor(environment: DeleGatorEnvironment, config?: CaveatBuilderConfig, enforcerBuilders?: TCaveatBuilderMap, builtCaveats?: CaveatStruct[]);
    extend<TEnforcerName extends string, TFunction extends (environment: DeleGatorEnvironment, ...args: [...any]) => CaveatStruct>(name: TEnforcerName, fn: TFunction): CaveatBuilder<TCaveatBuilderMap & Record<TEnforcerName, TFunction>>;
    addCaveat<TEnforcerName extends keyof TCaveatBuilderMap>(name: TEnforcerName, ...args: RemoveFirst<Parameters<TCaveatBuilderMap[TEnforcerName]>>): CaveatBuilder<TCaveatBuilderMap>;
    build(): CaveatStruct[];
}

declare const createCaveatBuilder: (environment: DeleGatorEnvironment, config?: CaveatBuilderConfig) => CaveatBuilder<Record<"allowedMethods", (environment: DeleGatorEnvironment, selectors: MethodSelector[]) => CaveatStruct> & Record<"allowedTargets", (environment: DeleGatorEnvironment, targets: `0x${string}`[]) => CaveatStruct> & Record<"deployed", (environment: DeleGatorEnvironment, contractAddress: `0x${string}`, salt: `0x${string}`, bytecode: `0x${string}`) => CaveatStruct> & Record<"allowedCalldata", (environment: DeleGatorEnvironment, startIndex: number, value: `0x${string}`) => CaveatStruct> & Record<"erc20BalanceGte", (environment: DeleGatorEnvironment, tokenAddress: `0x${string}`, balance: bigint) => CaveatStruct> & Record<"erc721BalanceGte", (environment: DeleGatorEnvironment, tokenAddress: `0x${string}`, recipient: `0x${string}`, amount: bigint) => CaveatStruct> & Record<"erc1155BalanceGte", (environment: DeleGatorEnvironment, tokenAddress: `0x${string}`, recipient: `0x${string}`, tokenId: bigint, balance: bigint) => CaveatStruct> & Record<"valueLte", (environment: DeleGatorEnvironment, maxValue: bigint) => CaveatStruct> & Record<"limitedCalls", (environment: DeleGatorEnvironment, limit: number) => CaveatStruct> & Record<"id", (environment: DeleGatorEnvironment, id: number) => CaveatStruct> & Record<"nonce", (environment: DeleGatorEnvironment, nonce: `0x${string}`) => CaveatStruct> & Record<"timestamp", (environment: DeleGatorEnvironment, timestampAfterThreshold: number, timestampBeforeThreshold: number) => CaveatStruct> & Record<"blockNumber", (environment: DeleGatorEnvironment, blockAfterThreshold: bigint, blockBeforeThreshold: bigint) => CaveatStruct> & Record<"erc20TransferAmount", (environment: DeleGatorEnvironment, tokenAddress: `0x${string}`, maxAmount: bigint) => CaveatStruct> & Record<"erc721Transfer", (environment: DeleGatorEnvironment, permittedContract: `0x${string}`, permittedTokenId: bigint) => CaveatStruct> & Record<"nativeTokenTransferAmount", (environment: DeleGatorEnvironment, allowance: bigint) => CaveatStruct> & Record<"nativeBalanceGte", (environment: DeleGatorEnvironment, recipient: `0x${string}`, balance: bigint) => CaveatStruct> & Record<"redeemer", (environment: DeleGatorEnvironment, redeemers: `0x${string}`[]) => CaveatStruct> & Record<"nativeTokenPayment", (environment: DeleGatorEnvironment, recipient: `0x${string}`, amount: bigint) => CaveatStruct> & Record<"argsEqualityCheck", (environment: DeleGatorEnvironment, args: `0x${string}`) => CaveatStruct> & Record<"ownershipTransfer", (environment: DeleGatorEnvironment, targetContract: `0x${string}`) => CaveatStruct>>;
type CoreCaveatBuilder = ReturnType<typeof createCaveatBuilder>;

type DelegationStruct = {
    delegate: Hex;
    delegator: Hex;
    authority: Hex;
    caveats: CaveatStruct[];
    salt: bigint;
    signature: Hex;
};
declare const encodeDelegation: (delegations: DelegationStruct[]) => `0x${string}`;
declare const encodePermissionContexts: (permissionContexts: DelegationStruct[][]) => `0x${string}`[];
declare const ROOT_AUTHORITY = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
declare const ANY_BENEFICIARY = "0x0000000000000000000000000000000000000a11";
declare const DELEGATION_TYPEHASH: `0x${string}`;
declare const DELEGATION_ABI_TYPE_COMPONENTS: ({
    type: string;
    name: string;
    components?: undefined;
} | {
    type: string;
    name: string;
    components: {
        type: string;
        name: string;
    }[];
})[];
declare const SIGNABLE_DELEGATION_TYPED_DATA: TypedData;
declare const DELEGATION_ARRAY_ABI_TYPE: AbiParameter;
declare const encodeDelegations: (delegations: DelegationStruct[]) => `0x${string}`;
declare const prepDelegationHashForPasskeySign: (delegationHash: Hex) => `0x${string}`;
declare const getDelegationHashOffchain: (input: DelegationStruct) => Hex;
declare const createDelegation: (delegate: Hex, delegator: Hex, authority: Hex, caveats: Caveats, salt?: bigint) => DelegationStruct;
declare const createOpenDelegation: (delegator: Hex, authority: Hex, caveats: Caveats, salt?: bigint) => DelegationStruct;
declare const createRootDelegation: (delegate: Hex, delegator: Hex, caveats: Caveats, salt?: bigint) => DelegationStruct;
declare const createOpenRootDelegation: (delegator: Hex, caveats: Caveats, salt?: bigint) => DelegationStruct;
declare const signDelegation: (signer: WalletClient<Transport, Chain, Account>, delegation: Omit<DelegationStruct, 'signature'>, delegationManager: Address, chainId: number, name?: string, version?: string) => Promise<`0x${string}`>;

type ExecutionStruct = {
    target: Hex;
    value: bigint;
    callData: Hex;
};
declare const createExecution: (target?: Hex, value?: bigint, callData?: Hex) => ExecutionStruct;
declare const SINGLE_DEFAULT_MODE = "0x0000000000000000000000000000000000000000000000000000000000000000";
declare const SINGLE_TRY_MODE = "0x0001000000000000000000000000000000000000000000000000000000000000";
declare const BATCH_DEFAULT_MODE = "0x0100000000000000000000000000000000000000000000000000000000000000";
declare const BATCH_TRY_MODE = "0x0101000000000000000000000000000000000000000000000000000000000000";
type ExecutionMode = typeof SINGLE_DEFAULT_MODE | typeof SINGLE_TRY_MODE | typeof BATCH_DEFAULT_MODE | typeof BATCH_TRY_MODE;
declare const EXECUTION_ABI_TYPE_COMPONENTS: {
    type: string;
    name: string;
}[];
declare const encodeSingleExecution: (execution: ExecutionStruct) => Hex;
declare const encodeBatchExecution: (executions: ExecutionStruct[]) => Hex;
declare const encodeExecutionCalldata: (executions: ExecutionStruct[]) => Hex;
declare const encodeExecutionCalldatas: (executionsBatch: ExecutionStruct[][]) => Hex[];

type UserOperationV07Hexlify = {
    sender: Hex;
    nonce: Hex;
    factory?: Hex;
    factoryData?: Hex;
    callData: Hex;
    callGasLimit: Hex;
    verificationGasLimit: Hex;
    preVerificationGas: Hex;
    maxFeePerGas: Hex;
    maxPriorityFeePerGas: Hex;
    paymaster?: Hex;
    paymasterVerificationGasLimit?: Hex;
    paymasterPostOpGasLimit?: Hex;
    paymasterData?: Hex;
    signature: Hex;
};
type UserOperationV07 = {
    sender: Hex;
    nonce: bigint;
    factory?: Hex;
    factoryData?: Hex;
    callData: Hex;
    callGasLimit: bigint;
    verificationGasLimit: bigint;
    preVerificationGas: bigint;
    maxFeePerGas: bigint;
    maxPriorityFeePerGas: bigint;
    paymaster?: Hex;
    paymasterVerificationGasLimit?: bigint;
    paymasterPostOpGasLimit?: bigint;
    paymasterData?: Hex;
    signature: Hex;
};
declare const createRawUserOp: (sender: Hex, nonce: bigint, callData: Hex, signature?: Hex, options?: OptionalUserOpProps) => UserOperationV07;
declare const getSalt: (salt?: Hex) => `0x${string}`;
declare const getPaymasterAndData: (userOp: UserOperationV07) => Hex;
declare const getInitCode: (userOp: UserOperationV07) => Hex;
declare const getAccountGasLimits: (userOp: UserOperationV07) => Hex;
declare const getGasFees: (userOp: UserOperationV07) => Hex;
declare const packUserOp: (userOp: UserOperationV07) => PackedUserOperationStruct;
declare const formatDelegationForSigning: (delegation: Optional<UnsignedDelegationStruct, 'authority'>) => {
    delegate: `0x${string}`;
    delegator: `0x${string}`;
    authority: `0x${string}`;
    caveats: {
        enforcer: `0x${string}`;
        terms: `0x${string}`;
        args: `0x${string}`;
    }[];
    salt: bigint;
};
declare const createUserOpHashV07: (packedOp: PackedUserOperationStruct, entryPoint: Hex, chainId: bigint) => `0x${string}`;
type SignUserOpParams = {
    userOp: UserOperationV07;
    entryPointAddress: string;
    chainId: number;
};
declare const SIGNABLE_USER_OP_TYPED_DATA: TypedData;

type Optional<T, K extends keyof T> = Omit<T, K> & Partial<T>;
type ContractMetaData = {
    bytecode: Hex;
    abi: Abi;
};
type DeleGatorEnvironment = {
    DelegationManager: Hex;
    EntryPoint: Hex;
    SimpleFactory: Hex;
    implementations: {
        [implementation: string]: Hex;
    };
    caveatEnforcers: {
        [enforcer: string]: Hex;
    };
};
type UnsignedDelegationStruct = Omit<DelegationStruct, 'signature'>;
type PackedUserOperationStruct = {
    sender: Hex;
    nonce: bigint;
    initCode: Hex;
    callData: Hex;
    accountGasLimits: Hex;
    preVerificationGas: bigint;
    gasFees: Hex;
    paymasterAndData: Hex;
    signature: Hex;
};
type GasDelegationStruct = {
    delegate: Hex;
    delegator: Hex;
    authority: Hex;
    allowList: Hex[];
    limitCount: bigint;
    limitCost: bigint;
    salt: bigint;
    signer: Hex;
    signature: Hex;
};
type EIP712DomainStruct = {
    name: string;
    version: string;
    chainId: bigint;
    verifyingContract: Hex;
};
type DelegationRedeemConfig = {
    delegationHash?: Hex;
    delegationChain?: DelegationStruct[];
};
type OptionalUserOpConfig = Omit<OptionalUserOpProps, 'factory' | 'factoryData'>;
type OptionalUserOpProps = {
    factory?: Hex;
    factoryData?: Hex;
    callGasLimit?: bigint;
    verificationGasLimit?: bigint;
    preVerificationGas?: bigint;
    maxFeePerGas?: bigint;
    maxPriorityFeePerGas?: bigint;
    paymaster?: Hex;
    paymasterVerificationGasLimit?: bigint;
    paymasterPostOpGasLimit?: bigint;
    paymasterData?: Hex;
};
type OptionalGasDelegationConfig = {
    salt?: bigint;
    allowList?: Hex[];
    authority?: Hex;
    signer?: Hex;
};
type MultiSigDeleGatorDeployParams = [signers: Hex[], threshold: bigint];
type HybridDeleGatorDeployParams = [
    owner: Hex,
    keyIds: string[],
    xValues: bigint[],
    yValues: bigint[]
];
type UserOperationGasEstimate = {
    preVerificationGas: bigint;
    verificationGas: bigint;
    validAfter: bigint;
    validUntil: bigint;
    callGasLimit: bigint;
};
type ExtendedUserOpStruct = UserOperationV07 & {
    entryPoint: Hex;
    blockNumber: any;
    blockHash: Hex;
    transactionHash: Hex;
};
type PaymasterFeeData = {
    feeBase: bigint;
    feeCap: bigint;
    systemFee: bigint;
};
type Redemption = {
    permissionContext: DelegationStruct[];
    executions: ExecutionStruct[];
    mode: ExecutionMode;
};
type DelegatorTypedData = TypedData | Record<string, unknown>;
type DelegatorPrimaryType = keyof DelegatorTypedData | 'EIP712Domain';
type DelegatorTypedDataDefinition = TypedDataDefinition<DelegatorTypedData, DelegatorPrimaryType>;
declare enum DelegationStoreFilter {
    Given = "GIVEN",
    Received = "RECEIVED",
    All = "ALL"
}

type StoredDelegation = {
    delegate: Hex;
    delegator: Hex;
    authority: Hex;
    caveats: CaveatStruct[];
    salt: Hex;
    signature: Hex;
};
type APIStoreDelegationResponse = {
    delegationHash: Hex;
};
declare const DelegationStorageEnvironment: {
    [K in 'dev' | 'prod']: Environment;
};
type Environment = {
    apiUrl: string;
};
type DelegationStorageConfig = {
    apiKey: string;
    apiKeyId: string;
    environment: Environment;
    fetcher?: typeof fetch;
};
declare class DelegationStorageClient {
    private readonly _apiVersionPrefix;
    private readonly _config;
    private readonly _fetcher;
    private readonly _apiUrl;
    constructor(config: DelegationStorageConfig);
    private _initializeFetcher;
    getDelegationChain(leafDelegationOrDelegationHash: Hex | DelegationStruct): Promise<DelegationStruct[]>;
    fetchDelegations(deleGatorAddress: Hex, filterMode?: DelegationStoreFilter): Promise<DelegationStruct[]>;
    storeDelegation(delegation: DelegationStruct): Promise<Hex>;
}

declare const getExplorerAddressLink: (chainId: number, address: string) => string;
declare const getExplorerTransactionLink: (chainId: number, hash: string) => string;
declare const shortenHash: (address: string | undefined) => string;
declare const getInfuraRpcUrl: (chainId: number, apiKey?: string) => string;

declare enum Implementation {
    MultiSig = 0,
    Hybrid = 1
}

declare function isEqualHex(a: Hex, b: Hex): boolean;
declare function deepHexlify(obj: any): any;

type SupportedVersion = '1.0.0' | '1.1.0' | '1.2.0';
declare const PREFERRED_VERSION: SupportedVersion;
declare function overrideDeployedEnvironment(chainId: number, version: SupportedVersion, environment: DeleGatorEnvironment): void;
declare function getDeleGatorEnvironment(chainId: number, version?: SupportedVersion): DeleGatorEnvironment;
declare function getDeleGatorEnvironment_v1(c: {
    [contract: string]: Hex;
}): DeleGatorEnvironment;
type DeployedContract = {
    name: string;
    address: string;
};
declare function deployDeleGatorEnvironment(walletClient: WalletClient, publicClient: PublicClient, chain: Chain, deployedContracts?: {
    [contract: string]: Hex;
}): Promise<DeleGatorEnvironment>;

type JSONRPCError = {
    message: string;
    code: number;
    data?: any;
};
declare class RpcError extends Error {
    readonly code: number;
    readonly data?: object;
    static INVALID_PARAMETERS: number;
    static INTERNAL_ERROR: number;
    static METHOD_NOT_SUPPORTED: number;
    static CONNECTION_CLOSED: number;
    static from(error: RpcError | Error | string): RpcError;
    toJSONRPCError(): JSONRPCError;
    constructor(message: string, code: number, data?: object);
}

declare const FIELD_MODULUS = 115792089210356248762697446949407573529996955224135760342422259061068512044369n;
declare const MALLEABILITY_THRESHOLD: bigint;
declare const SIGNATURE_ABI_PARAMS: readonly [{
    readonly type: "bytes32";
}, {
    readonly type: "uint256";
}, {
    readonly type: "uint256";
}, {
    readonly type: "bytes";
}, {
    readonly type: "bool";
}, {
    readonly type: "string";
}, {
    readonly type: "string";
}, {
    readonly type: "uint256";
}];
declare const splitOnChallenge: (clientDataJson: string) => [clientDataJSONPrefix: string, clientDataJSONSuffix: string];
declare const getResponseTypeLocation: (clientDataJson: string) => bigint;
declare function encodeDeleGatorSignature(keyId: string, signature: Hex, clientDataJSON: string, authenticatorData: Hex): Hex;
type AuthenticatorFlags = {
    userVerified: boolean;
};
declare function parseAuthenticatorFlags(authenticatorData: Hex): AuthenticatorFlags;
declare const createDummyWebAuthnSignature: (keyId: Hex) => `0x${string}`;

declare const deployWithSimpleFactory: (walletClient: WalletClient, publicClient: PublicClient, simpleFactoryAddress: Address, creationCode: Hex, salt: bigint) => Promise<`0x${string}`>;
declare const redeemDelegations: (walletClient: WalletClient, publicClient: PublicClient, delegationManagerAddress: Address, redemptions: Redemption[]) => Promise<`0x${string}`>;
declare function deployContract(walletClient: WalletClient, publicClient: PublicClient, chain: Chain, { bytecode, abi }: ContractMetaData, args?: any[]): Promise<{
    address: `0x${string}`;
    hash: `0x${string}`;
    receipt: viem.TransactionReceipt;
}>;

export { ANY_BENEFICIARY, APIStoreDelegationResponse, AuthenticatorFlags, BATCH_DEFAULT_MODE, BATCH_TRY_MODE, CAVEAT_ABI_TYPE_COMPONENTS, CAVEAT_TYPEHASH, CaveatBuilder, CaveatBuilderConfig, CaveatStruct, Caveats, ContractMetaData, CoreCaveatBuilder, DELEGATION_ABI_TYPE_COMPONENTS, DELEGATION_ARRAY_ABI_TYPE, DELEGATION_TYPEHASH, DeleGatorEnvironment, DelegationRedeemConfig, DelegationStorageClient, DelegationStorageConfig, DelegationStorageEnvironment, DelegationStoreFilter, DelegationStruct, DelegatorPrimaryType, DelegatorTypedData, DelegatorTypedDataDefinition, DeployedContract, EIP712DomainStruct, EXECUTION_ABI_TYPE_COMPONENTS, Environment, ExecutionMode, ExecutionStruct, ExtendedUserOpStruct, FIELD_MODULUS, GasDelegationStruct, HybridDeleGatorDeployParams, Implementation, JSONRPCError, MALLEABILITY_THRESHOLD, MultiSigDeleGatorDeployParams, Optional, OptionalGasDelegationConfig, OptionalUserOpConfig, OptionalUserOpProps, PREFERRED_VERSION, PackedUserOperationStruct, PaymasterFeeData, ROOT_AUTHORITY, Redemption, RpcError, SIGNABLE_DELEGATION_TYPED_DATA, SIGNABLE_USER_OP_TYPED_DATA, SIGNATURE_ABI_PARAMS, SINGLE_DEFAULT_MODE, SINGLE_TRY_MODE, SignUserOpParams, StoredDelegation, UnsignedDelegationStruct, UserOperationGasEstimate, UserOperationV07, UserOperationV07Hexlify, createCaveat, createCaveatBuilder, createDelegation, createDummyWebAuthnSignature, createExecution, createOpenDelegation, createOpenRootDelegation, createRawUserOp, createRootDelegation, createUserOpHashV07, deepHexlify, deployContract, deployDeleGatorEnvironment, deployWithSimpleFactory, encodeBatchExecution, encodeDeleGatorSignature, encodeDelegation, encodeDelegations, encodeExecutionCalldata, encodeExecutionCalldatas, encodePermissionContexts, encodeSingleExecution, formatDelegationForSigning, getAccountGasLimits, getCaveatArrayPacketHash, getCaveatPacketHash, getDeleGatorEnvironment, getDeleGatorEnvironment_v1, getDelegationHashOffchain, getExplorerAddressLink, getExplorerTransactionLink, getGasFees, getInfuraRpcUrl, getInitCode, getPaymasterAndData, getResponseTypeLocation, getSalt, isEqualHex, overrideDeployedEnvironment, packUserOp, parseAuthenticatorFlags, prepDelegationHashForPasskeySign, redeemDelegations, resolveCaveats, shortenHash, signDelegation, splitOnChallenge };
