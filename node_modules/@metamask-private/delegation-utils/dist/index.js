"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _createStarExport(obj) { Object.keys(obj) .filter((key) => key !== "default" && key !== "__esModule") .forEach((key) => { if (exports.hasOwnProperty(key)) { return; } Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]}); }); } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class; var _class2; var _class3;// src/index.ts
var _delegationdeployments = require('@metamask-private/delegation-deployments'); _createStarExport(_delegationdeployments);
var _delegationabis = require('@metamask-private/delegation-abis'); _createStarExport(_delegationabis);

// src/delegationStorage.ts
var _viem = require('viem');

// src/delegation.ts









// src/caveats.ts







var CAVEAT_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "enforcer" },
  { type: "bytes", name: "terms" },
  { type: "bytes", name: "args" }
];
var CAVEAT_TYPEHASH = _viem.keccak256.call(void 0, 
  _viem.toHex.call(void 0, "Caveat(address enforcer,bytes terms)")
);
var getCaveatArrayPacketHash = (input) => {
  let encoded = "0x";
  for (let i = 0; i < input.length; ++i) {
    const caveatPacketHash = getCaveatPacketHash(input[i]);
    encoded = _viem.encodePacked.call(void 0, ["bytes", "bytes32"], [encoded, caveatPacketHash]);
  }
  return _viem.keccak256.call(void 0, encoded);
};
var getCaveatPacketHash = (input) => {
  const encoded = _viem.encodeAbiParameters.call(void 0, 
    _viem.parseAbiParameters.call(void 0, "bytes32, address, bytes32"),
    [CAVEAT_TYPEHASH, input.enforcer, _viem.keccak256.call(void 0, input.terms)]
  );
  return _viem.keccak256.call(void 0, encoded);
};
var createCaveat = (enforcer, terms, args = "0x") => ({
  enforcer,
  terms,
  args
});

// src/caveatBuilder/allowedMethodsBuilder.ts

var allowedMethods = "allowedMethods";
var FUNCTION_SELECTOR_STRING_LENGTH = 10;
var allowedMethodsBuilder = (environment, selectors) => {
  if (selectors.length === 0) {
    throw new Error("Invalid selectors: must provide at least one selector");
  }
  const parsedSelectors = selectors.map(parseSelector);
  const terms = _viem.concat.call(void 0, parsedSelectors);
  const {
    caveatEnforcers: { AllowedMethodsEnforcer: AllowedMethodsEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedMethodsEnforcer2,
    terms,
    args: "0x"
  };
};
function parseSelector(selector) {
  if (_viem.isHex.call(void 0, selector)) {
    if (selector.length !== FUNCTION_SELECTOR_STRING_LENGTH) {
      throw new Error(
        "Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction"
      );
    } else {
      return selector;
    }
  }
  try {
    return _viem.toFunctionSelector.call(void 0, selector);
  } catch (rootError) {
    throw new Error(
      "Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction",
      { cause: rootError }
    );
  }
}

// src/caveatBuilder/allowedTargetsBuilder.ts

var allowedTargets = "allowedTargets";
var allowedTargetsBuilder = (environment, targets) => {
  if (targets.length === 0) {
    throw new Error(
      "Invalid targets: must provide at least one target address"
    );
  }
  const invalidAddresses = targets.filter(
    (target) => !_viem.isAddress.call(void 0, target, { strict: false })
  );
  if (invalidAddresses.length > 0) {
    throw new Error("Invalid targets: must be valid addresses");
  }
  const terms = _viem.concat.call(void 0, targets);
  const {
    caveatEnforcers: { AllowedTargetsEnforcer: AllowedTargetsEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedTargetsEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/caveatBuilder.ts
var resolveCaveats = (caveats) => {
  if (Array.isArray(caveats)) {
    return caveats;
  }
  return caveats.build();
};
var CaveatBuilder = (_class = class _CaveatBuilder {
  constructor(environment, config = {}, enforcerBuilders = {}, builtCaveats = []) {;_class.prototype.__init.call(this);_class.prototype.__init2.call(this);
    this.environment = environment;
    this.config = config;
    this.enforcerBuilders = enforcerBuilders;
    this.results = builtCaveats;
  }
  __init() {this.results = []}
  __init2() {this.hasBeenBuilt = false}
  /**
   * Extends the CaveatBuilder with a new enforcer function.
   *
   * @template TEnforcerName - The name of the enforcer.
   * @template TFunction - The type of the enforcer function.
   * @param name - The name of the enforcer.
   * @param fn - The enforcer function.
   * @returns The extended CaveatBuilder instance.
   */
  extend(name, fn) {
    return new _CaveatBuilder(
      this.environment,
      this.config,
      { ...this.enforcerBuilders, [name]: fn },
      this.results
    );
  }
  /**
   * Adds a caveat to the CaveatBuilder instance.
   *
   * The function modifies the caveats represented by the current CaveatBuilder
   * instance, but also returns the CaveatBuilder instance to facilitate call
   * chaining.
   *
   * @template TEnforcerName - The type of the enforcer name.
   * @param name - The name of the enforcer.
   * @param args - The arguments for the enforcer function.
   * @returns The CaveatBuilder instance.
   * @throws If the specified enforcer function does not exist.
   */
  addCaveat(name, ...args) {
    const func = this.enforcerBuilders[name];
    if (typeof func === "function") {
      const result = func(this.environment, ...args);
      this.results = [...this.results, result];
      return this;
    }
    throw new Error(`Function "${String(name)}" does not exist.`);
  }
  /**
   * Returns the caveats that have been built using this CaveatBuilder.
   *
   * @returns The array of built caveats.
   */
  build() {
    if (this.hasBeenBuilt) {
      throw new Error("This CaveatBuilder has already been built.");
    }
    if (this.results.length === 0 && !this.config.allowEmptyCaveats) {
      throw new Error(
        "No caveats found. If you definitely want to create an empty caveat collection, set `allowEmptyCaveats`."
      );
    }
    this.hasBeenBuilt = true;
    return this.results;
  }
}, _class);

// src/caveatBuilder/deployedBuilder.ts

var deployed = "deployed";
var deployedBuilder = (environment, contractAddress, salt, bytecode) => {
  if (!_viem.isAddress.call(void 0, contractAddress, { strict: false })) {
    throw new Error(
      `Invalid contractAddress: must be a valid Ethereum address`
    );
  }
  if (!_viem.isHex.call(void 0, salt)) {
    throw new Error("Invalid salt: must be a valid hexadecimal string");
  }
  if (!_viem.isHex.call(void 0, bytecode)) {
    throw new Error("Invalid bytecode: must be a valid hexadecimal string");
  }
  const terms = _viem.concat.call(void 0, [contractAddress, _viem.pad.call(void 0, salt, { size: 32 }), bytecode]);
  const {
    caveatEnforcers: { DeployedEnforcer: DeployedEnforcer2 }
  } = environment;
  return {
    enforcer: DeployedEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/allowedCalldataBuilder.ts

var allowedCalldata = "allowedCalldata";
var allowedCalldataBuilder = (environment, startIndex, value) => {
  if (!_viem.isHex.call(void 0, value)) {
    throw new Error("Invalid value: must be a valid hex string");
  }
  if (startIndex < 0) {
    throw new Error("Invalid startIndex: must be zero or positive");
  }
  if (!Number.isInteger(startIndex)) {
    throw new Error("Invalid startIndex: must be a whole number");
  }
  const startIndexHex = _viem.toHex.call(void 0, startIndex, { size: 32 });
  const terms = _viem.concat.call(void 0, [startIndexHex, value]);
  const {
    caveatEnforcers: { AllowedCalldataEnforcer: AllowedCalldataEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedCalldataEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20BalanceGteBuilder.ts

var erc20BalanceGte = "erc20BalanceGte";
var erc20BalanceGteBuilder = (environment, tokenAddress, balance) => {
  if (!_viem.isAddress.call(void 0, tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  const terms = _viem.encodePacked.call(void 0, ["address", "uint256"], [tokenAddress, balance]);
  const {
    caveatEnforcers: { ERC20BalanceGteEnforcer: ERC20BalanceGteEnforcer2 }
  } = environment;
  return {
    enforcer: ERC20BalanceGteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/valueLteBuilder.ts

var valueLte = "valueLte";
var valueLteBuilder = (environment, maxValue) => {
  if (maxValue < 0n) {
    throw new Error("Invalid maxValue: must be greater than zero");
  }
  const terms = _viem.concat.call(void 0, [_viem.toHex.call(void 0, maxValue, { size: 32 })]);
  const {
    caveatEnforcers: { ValueLteEnforcer: ValueLteEnforcer2 }
  } = environment;
  return {
    enforcer: ValueLteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/limitedCallsBuilder.ts

var limitedCalls = "limitedCalls";
var limitedCallsBuilder = (environment, limit) => {
  if (!Number.isInteger(limit)) {
    throw new Error("Invalid limit: must be an integer");
  }
  if (limit <= 0) {
    throw new Error("Invalid limit: must be a positive integer");
  }
  const terms = _viem.pad.call(void 0, _viem.toHex.call(void 0, limit), { size: 32 });
  const {
    caveatEnforcers: { LimitedCallsEnforcer: LimitedCallsEnforcer2 }
  } = environment;
  return {
    enforcer: LimitedCallsEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/idBuilder.ts

var id = "id";
var idBuilder = (environment, id2) => {
  if (typeof id2 !== "number") {
    throw new Error("Invalid id: must be a number");
  }
  if (!Number.isInteger(id2)) {
    throw new Error("Invalid id: must be an integer");
  }
  if (id2 >= 2 ** 32) {
    throw new Error("Invalid id: must be 32 bytes or fewer in length");
  }
  const terms = _viem.toHex.call(void 0, id2, { size: 32 });
  const {
    caveatEnforcers: { IdEnforcer: IdEnforcer2 }
  } = environment;
  return {
    enforcer: IdEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nonceBuilder.ts

var nonce = "nonce";
var MAX_NONCE_STRING_LENGTH = 66;
var nonceBuilder = (environment, nonce2) => {
  if (!nonce2 || nonce2 === "0x") {
    throw new Error("Invalid nonce: must be a non-empty hex string");
  }
  if (!_viem.isHex.call(void 0, nonce2)) {
    throw new Error("Invalid nonce: must be a valid hex string");
  }
  if (nonce2.length > MAX_NONCE_STRING_LENGTH) {
    throw new Error("Invalid nonce: must be 32 bytes or less in length");
  }
  const {
    caveatEnforcers: { NonceEnforcer: NonceEnforcer2 }
  } = environment;
  return {
    enforcer: NonceEnforcer2,
    terms: _viem.pad.call(void 0, nonce2, { size: 32 }),
    args: "0x"
  };
};

// src/caveatBuilder/timestampBuilder.ts

var timestamp = "timestamp";
var timestampBuilder = (environment, timestampAfterThreshold, timestampBeforeThreshold) => {
  if (timestampAfterThreshold < 0) {
    throw new Error(
      "Invalid timestampAfterThreshold: must be zero or positive"
    );
  }
  if (timestampBeforeThreshold < 0) {
    throw new Error(
      "Invalid timestampBeforeThreshold: must be zero or positive"
    );
  }
  if (timestampBeforeThreshold !== 0 && timestampAfterThreshold >= timestampBeforeThreshold) {
    throw new Error(
      "Invalid thresholds: timestampBeforeThreshold must be greater than timestampAfterThreshold when both are specified"
    );
  }
  const afterThresholdHex = _viem.toHex.call(void 0, timestampAfterThreshold, { size: 16 });
  const beforeThresholdHex = _viem.toHex.call(void 0, timestampBeforeThreshold, { size: 16 });
  const terms = _viem.concat.call(void 0, [afterThresholdHex, beforeThresholdHex]);
  const {
    caveatEnforcers: { TimestampEnforcer: TimestampEnforcer2 }
  } = environment;
  return {
    enforcer: TimestampEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/blockNumberBuilder.ts

var blockNumber = "blockNumber";
var blockNumberBuilder = (environment, blockAfterThreshold, blockBeforeThreshold) => {
  if (blockAfterThreshold === 0n && blockBeforeThreshold === 0n) {
    throw new Error(
      "Invalid thresholds: At least one of blockAfterThreshold or blockBeforeThreshold must be specified"
    );
  }
  if (blockBeforeThreshold !== 0n && blockAfterThreshold >= blockBeforeThreshold) {
    throw new Error(
      "Invalid thresholds: blockAfterThreshold must be less than blockBeforeThreshold if both are specified"
    );
  }
  const terms = _viem.concat.call(void 0, [
    _viem.toHex.call(void 0, blockAfterThreshold, {
      size: 16
    }),
    _viem.toHex.call(void 0, blockBeforeThreshold, {
      size: 16
    })
  ]);
  const {
    caveatEnforcers: { BlockNumberEnforcer: BlockNumberEnforcer2 }
  } = environment;
  return {
    enforcer: BlockNumberEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20TransferAmountBuilder.ts

var erc20TransferAmount = "erc20TransferAmount";
var erc20TransferAmountBuilder = (environment, tokenAddress, maxAmount) => {
  if (!_viem.isAddress.call(void 0, tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (maxAmount <= 0n) {
    throw new Error("Invalid maxAmount: must be a positive number");
  }
  const terms = _viem.concat.call(void 0, [tokenAddress, _viem.toHex.call(void 0, maxAmount, { size: 32 })]);
  const {
    caveatEnforcers: { ERC20TransferAmountEnforcer: ERC20TransferAmountEnforcer2 }
  } = environment;
  return {
    enforcer: ERC20TransferAmountEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenTransferAmountBuilder.ts

var nativeTokenTransferAmount = "nativeTokenTransferAmount";
var nativeTokenTransferAmountBuilder = (environment, allowance) => {
  if (allowance < 0n) {
    throw new Error("Invalid allowance: must be zero or positive");
  }
  const terms = _viem.encodePacked.call(void 0, ["uint256"], [allowance]);
  const {
    caveatEnforcers: { NativeTokenTransferAmountEnforcer: NativeTokenTransferAmountEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenTransferAmountEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeBalanceGteBuilder.ts

var nativeBalanceGte = "nativeBalanceGte";
var nativeBalanceGteBuilder = (environment, recipient, balance) => {
  if (!_viem.isAddress.call(void 0, recipient)) {
    throw new Error("Invalid recipient: must be a valid Address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  const terms = _viem.encodePacked.call(void 0, ["address", "uint256"], [recipient, balance]);
  const {
    caveatEnforcers: { NativeBalanceGteEnforcer: NativeBalanceGteEnforcer2 }
  } = environment;
  return {
    enforcer: NativeBalanceGteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/redeemerBuilder.ts

var redeemer = "redeemer";
var redeemerBuilder = (environment, redeemers) => {
  if (redeemers.length === 0) {
    throw new Error(
      "Invalid redeemers: must specify at least one redeemer address"
    );
  }
  for (let i = 0; i < redeemers.length; i++) {
    if (!_viem.isAddress.call(void 0, redeemers[i])) {
      throw new Error("Invalid redeemers: must be a valid address");
    }
  }
  const terms = _viem.concat.call(void 0, redeemers);
  const {
    caveatEnforcers: { RedeemerEnforcer: RedeemerEnforcer2 }
  } = environment;
  return {
    enforcer: RedeemerEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenPaymentBuilder.ts

var nativeTokenPayment = "nativeTokenPayment";
var nativeTokenPaymentBuilder = (environment, recipient, amount) => {
  if (amount <= 0n) {
    throw new Error("Invalid amount: must be positive");
  }
  if (!_viem.isAddress.call(void 0, recipient)) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  const terms = _viem.encodePacked.call(void 0, ["address", "uint256"], [recipient, amount]);
  const {
    caveatEnforcers: { NativeTokenPaymentEnforcer: NativeTokenPaymentEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenPaymentEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/argsEqualityCheckBuilder.ts

var argsEqualityCheck = "argsEqualityCheck";
var argsEqualityCheckBuilder = (environment, args) => {
  if (!_viem.isHex.call(void 0, args)) {
    throw new Error("Invalid args: must be a valid hex string");
  }
  const terms = args;
  const {
    caveatEnforcers: { ArgsEqualityCheckEnforcer: ArgsEqualityCheckEnforcer2 }
  } = environment;
  return {
    enforcer: ArgsEqualityCheckEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc1155BalanceGteBuilder.ts

var erc1155BalanceGte = "erc1155BalanceGte";
var erc1155BalanceGteBuilder = (environment, tokenAddress, recipient, tokenId, balance) => {
  if (!_viem.isAddress.call(void 0, tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (!_viem.isAddress.call(void 0, recipient, { strict: false })) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  if (tokenId < 0) {
    throw new Error("Invalid tokenId: must be a non-negative number");
  }
  const terms = _viem.concat.call(void 0, [
    tokenAddress,
    recipient,
    _viem.toHex.call(void 0, tokenId, { size: 32 }),
    _viem.toHex.call(void 0, balance, { size: 32 })
  ]);
  const {
    caveatEnforcers: { ERC1155BalanceGteEnforcer: ERC1155BalanceGteEnforcer2 }
  } = environment;
  return {
    enforcer: ERC1155BalanceGteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc721BalanceGteBuilder.ts

var erc721BalanceGte = "erc721BalanceGte";
var erc721BalanceGteBuilder = (environment, tokenAddress, recipient, amount) => {
  if (!_viem.isAddress.call(void 0, tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (!_viem.isAddress.call(void 0, recipient, { strict: false })) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  if (amount <= 0) {
    throw new Error("Invalid balance: must be a positive number");
  }
  const terms = _viem.concat.call(void 0, [tokenAddress, recipient, _viem.toHex.call(void 0, amount, { size: 32 })]);
  const {
    caveatEnforcers: { ERC721BalanceGteEnforcer: ERC721BalanceGteEnforcer2 }
  } = environment;
  return {
    enforcer: ERC721BalanceGteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc721TransferBuilder.ts

var erc721Transfer = "erc721Transfer";
var erc721TransferBuilder = (environment, permittedContract, permittedTokenId) => {
  if (!_viem.isAddress.call(void 0, permittedContract, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (permittedTokenId < 0) {
    throw new Error("Invalid permittedTokenId: must be a non-negative number");
  }
  const terms = _viem.concat.call(void 0, [
    permittedContract,
    _viem.toHex.call(void 0, permittedTokenId, { size: 32 })
  ]);
  const {
    caveatEnforcers: { ERC721TransferEnforcer: ERC721TransferEnforcer2 }
  } = environment;
  return {
    enforcer: ERC721TransferEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/ownershipTransferBuilder.ts

var ownershipTransfer = "ownershipTransfer";
var ownershipTransferBuilder = (environment, targetContract) => {
  if (!_viem.isAddress.call(void 0, targetContract, { strict: false })) {
    throw new Error("Invalid targetContract: must be a valid address");
  }
  const terms = targetContract;
  const {
    caveatEnforcers: { OwnershipTransferEnforcer: OwnershipTransferEnforcer2 }
  } = environment;
  return {
    enforcer: OwnershipTransferEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/index.ts
var createCaveatBuilder = (environment, config) => {
  const caveatBuilder = new CaveatBuilder(environment, config).extend(allowedMethods, allowedMethodsBuilder).extend(allowedTargets, allowedTargetsBuilder).extend(deployed, deployedBuilder).extend(allowedCalldata, allowedCalldataBuilder).extend(erc20BalanceGte, erc20BalanceGteBuilder).extend(erc721BalanceGte, erc721BalanceGteBuilder).extend(erc1155BalanceGte, erc1155BalanceGteBuilder).extend(valueLte, valueLteBuilder).extend(limitedCalls, limitedCallsBuilder).extend(id, idBuilder).extend(nonce, nonceBuilder).extend(timestamp, timestampBuilder).extend(blockNumber, blockNumberBuilder).extend(erc20TransferAmount, erc20TransferAmountBuilder).extend(erc721Transfer, erc721TransferBuilder).extend(nativeTokenTransferAmount, nativeTokenTransferAmountBuilder).extend(nativeBalanceGte, nativeBalanceGteBuilder).extend(redeemer, redeemerBuilder).extend(nativeTokenPayment, nativeTokenPaymentBuilder).extend(argsEqualityCheck, argsEqualityCheckBuilder).extend(ownershipTransfer, ownershipTransferBuilder);
  return caveatBuilder;
};

// src/delegation.ts
var encodeDelegation = (delegations) => {
  return _viem.encodeAbiParameters.call(void 0, 
    [
      {
        components: DELEGATION_ABI_TYPE_COMPONENTS,
        name: "delegations",
        type: "tuple[]"
      }
    ],
    [delegations]
  );
};
var encodePermissionContexts = (permissionContexts) => {
  const encodedDelegations = permissionContexts.map(
    (delegationChain) => encodeDelegation(delegationChain)
  );
  return encodedDelegations;
};
var ROOT_AUTHORITY = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
var ANY_BENEFICIARY = "0x0000000000000000000000000000000000000a11";
var DELEGATION_TYPEHASH = _viem.keccak256.call(void 0, 
  _viem.toHex.call(void 0, 
    "Delegation(address delegate,address delegator,bytes32 authority,Caveat[] caveats,uint256 salt)Caveat(address enforcer,bytes terms)"
  )
);
var DELEGATION_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "delegate" },
  { type: "address", name: "delegator" },
  { type: "bytes32", name: "authority" },
  { type: "tuple[]", name: "caveats", components: CAVEAT_ABI_TYPE_COMPONENTS },
  { type: "uint256", name: "salt" },
  { type: "bytes", name: "signature" }
];
var SIGNABLE_DELEGATION_TYPED_DATA = {
  Caveat: [
    { name: "enforcer", type: "address" },
    { name: "terms", type: "bytes" }
  ],
  Delegation: [
    { name: "delegate", type: "address" },
    { name: "delegator", type: "address" },
    { name: "authority", type: "bytes32" },
    { name: "caveats", type: "Caveat[]" },
    { name: "salt", type: "uint256" }
  ]
};
var DELEGATION_ARRAY_ABI_TYPE = {
  type: "tuple[]",
  components: DELEGATION_ABI_TYPE_COMPONENTS
};
var encodeDelegations = (delegations) => _viem.encodeAbiParameters.call(void 0, [DELEGATION_ARRAY_ABI_TYPE], [delegations]);
var prepDelegationHashForPasskeySign = (delegationHash) => {
  return _viem.hashMessage.call(void 0, {
    raw: _viem.toBytes.call(void 0, delegationHash)
  });
};
var getDelegationHashOffchain = (input) => {
  const encoded = _viem.encodeAbiParameters.call(void 0, 
    _viem.parseAbiParameters.call(void 0, "bytes32, address, address, bytes32, bytes32, uint"),
    [
      DELEGATION_TYPEHASH,
      input.delegate,
      input.delegator,
      input.authority,
      getCaveatArrayPacketHash(input.caveats),
      input.salt
    ]
  );
  return _viem.keccak256.call(void 0, encoded);
};
var createDelegation = (delegate, delegator, authority, caveats, salt = 0n) => ({
  delegate,
  delegator,
  authority,
  caveats: resolveCaveats(caveats),
  salt,
  signature: "0x"
});
var createOpenDelegation = (delegator, authority, caveats, salt) => createDelegation(ANY_BENEFICIARY, delegator, authority, caveats, salt);
var createRootDelegation = (delegate, delegator, caveats, salt) => createDelegation(delegate, delegator, ROOT_AUTHORITY, caveats, salt);
var createOpenRootDelegation = (delegator, caveats, salt) => createDelegation(ANY_BENEFICIARY, delegator, ROOT_AUTHORITY, caveats, salt);
var signDelegation = async (signer, delegation, delegationManager, chainId, name = "DelegationManager", version = "1") => signer.signTypedData({
  account: signer.account,
  domain: {
    chainId,
    name,
    version,
    verifyingContract: delegationManager
  },
  types: SIGNABLE_DELEGATION_TYPED_DATA,
  primaryType: "Delegation",
  message: delegation
});

// src/types.ts
var DelegationStoreFilter = /* @__PURE__ */ ((DelegationStoreFilter2) => {
  DelegationStoreFilter2["Given"] = "GIVEN";
  DelegationStoreFilter2["Received"] = "RECEIVED";
  DelegationStoreFilter2["All"] = "ALL";
  return DelegationStoreFilter2;
})(DelegationStoreFilter || {});

// src/delegationStorage.ts
var DelegationStorageEnvironment = {
  dev: { apiUrl: "https://passkeys.dev-api.cx.metamask.io" },
  prod: { apiUrl: "https://passkeys.api.cx.metamask.io" }
};
var DelegationStorageClient = (_class2 = class {
  __init3() {this._apiVersionPrefix = "api/v0"}
  
  
  
  constructor(config) {;_class2.prototype.__init3.call(this);
    let apiUrl = config.environment.apiUrl.replace(/\/+$/, "");
    if (!apiUrl.endsWith(this._apiVersionPrefix)) {
      apiUrl = `${apiUrl}/${this._apiVersionPrefix}`;
    }
    this._fetcher = this._initializeFetcher(config);
    this._config = config;
    this._apiUrl = apiUrl;
  }
  /**
   * Initializes the fetch function for HTTP requests.
   *
   * - Uses `config.fetcher` if provided.
   * - Falls back to global `fetch` if available.
   * - Throws an error if no fetch function is available.
   *
   * @param config - Configuration object that may include a custom fetch function.
   * @returns The fetch function to be used for HTTP requests.
   * @throws Error if no fetch function is available in the environment.
   */
  _initializeFetcher(config) {
    if (config.fetcher) {
      return config.fetcher;
    } else if (typeof _optionalChain([globalThis, 'optionalAccess', _2 => _2.fetch]) === "function") {
      return globalThis.fetch.bind(globalThis);
    } else {
      throw new Error(
        "Fetch API is not available in this environment. Please provide a fetch function in the config."
      );
    }
  }
  /**
   * Fetch the delegation chain from the Delegation Storage Service, ending with
   * the specified leaf delegation.
   *
   * @param leafDelegationOrDelegationHash - the leaf delegation, or the hash
   * of the leaf delegation
   * @returns resolves to the delegation chain - empty array if the delegation
   * is not found.
   */
  async getDelegationChain(leafDelegationOrDelegationHash) {
    const leafDelegationHash = typeof leafDelegationOrDelegationHash === "string" ? leafDelegationOrDelegationHash : getDelegationHashOffchain(leafDelegationOrDelegationHash);
    const response = await this._fetcher(
      `${this._apiUrl}/delegation/chain/${leafDelegationHash}`,
      {
        method: "GET",
        headers: {
          Authorization: `Bearer ${this._config.apiKey}`,
          "x-api-key-id": this._config.apiKeyId
        }
      }
    );
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(
        `Failed to fetch delegation chain: ${responseData.error}`
      );
    }
    return responseData.map((delegation) => ({
      ...delegation,
      salt: BigInt(delegation.salt)
    }));
  }
  /**
   * Fetch the delegations from the Delegation Storage Service, either `Received`
   * by, or `Given` by, (or both: `All`) the specified deleGatorAddress. Defaults
   * to `Received`
   *
   * @param deleGatorAddress - The deleGatorAddress to retrieve the delegations for.
   * @param filterMode - the DelegationStoreFilter mode - defaults to Received
   * @returns resolves to the list of delegations received by the deleGatorAddress, empty array if the delegations are not found.
   */
  async fetchDelegations(deleGatorAddress, filterMode = "RECEIVED" /* Received */) {
    const response = await this._fetcher(
      `${this._apiUrl}/delegation/accounts/${deleGatorAddress}?filter=${filterMode}`,
      {
        method: "GET",
        headers: {
          Authorization: `Bearer ${this._config.apiKey}`,
          "x-api-key-id": this._config.apiKeyId
        }
      }
    );
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(`Failed to fetch delegations: ${responseData.error}`);
    }
    return responseData.map((delegation) => ({
      ...delegation,
      salt: BigInt(delegation.salt)
    }));
  }
  /**
   * Store the specified delegation in the Delegation Storage Service.
   *
   * @param delegation - the delegation to store
   * @returns resolves to the delegation hash indicating successfully stored
   */
  async storeDelegation(delegation) {
    if (!delegation.signature || delegation.signature === "0x") {
      throw new Error("Delegation must be signed to be stored");
    }
    const delegationHash = getDelegationHashOffchain(delegation);
    const body = JSON.stringify(
      {
        ...delegation,
        metadata: []
      },
      (_, value) => typeof value === "bigint" || typeof value === "number" ? _viem.toHex.call(void 0, value) : value,
      2
    );
    const response = await this._fetcher(`${this._apiUrl}/delegation/store`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this._config.apiKey}`,
        "x-api-key-id": this._config.apiKeyId,
        "Content-Type": "application/json"
      },
      body
    });
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(responseData.error);
    }
    if (responseData.delegationHash !== delegationHash) {
      throw Error(
        "Failed to store the Delegation, the hash returned from the MM delegation storage API does not match the hash of the delegation"
      );
    }
    return responseData.delegationHash;
  }
}, _class2);

// src/executions.ts

var createExecution = (target = _viem.zeroAddress, value = BigInt(0), callData = "0x") => ({
  target,
  value,
  callData
});
var SINGLE_DEFAULT_MODE = "0x0000000000000000000000000000000000000000000000000000000000000000";
var SINGLE_TRY_MODE = "0x0001000000000000000000000000000000000000000000000000000000000000";
var BATCH_DEFAULT_MODE = "0x0100000000000000000000000000000000000000000000000000000000000000";
var BATCH_TRY_MODE = "0x0101000000000000000000000000000000000000000000000000000000000000";
var EXECUTION_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "target" },
  { type: "uint256", name: "value" },
  { type: "bytes", name: "callData" }
];
var encodeSingleExecution = (execution) => {
  return _viem.encodePacked.call(void 0, 
    ["address", "uint256", "bytes"],
    [execution.target, execution.value, execution.callData]
  );
};
var encodeBatchExecution = (executions) => {
  return _viem.encodeAbiParameters.call(void 0, 
    [
      {
        components: EXECUTION_ABI_TYPE_COMPONENTS,
        name: "executions",
        type: "tuple[]"
      }
    ],
    [executions]
  );
};
var encodeExecutionCalldata = (executions) => {
  if (executions.length == 0) {
    throw new Error(
      `Error while getting the execution calldatas, executions is empty`
    );
  }
  if (executions.length == 1) {
    const execution = executions[0];
    return encodeSingleExecution(execution);
  }
  return encodeBatchExecution(executions);
};
var encodeExecutionCalldatas = (executionsBatch) => {
  if (executionsBatch.length == 0) {
    throw new Error(
      `Error while getting the execution calldatas, executionsBatch is empty`
    );
  }
  return executionsBatch.map(encodeExecutionCalldata);
};

// src/blockchain.ts

var getExplorerAddressLink = (chainId, address) => {
  const prefix = getExplorerLink(chainId);
  return `${prefix}/address/${address}`;
};
var getExplorerTransactionLink = (chainId, hash) => {
  const prefix = getExplorerLink(chainId);
  return `${prefix}/tx/${hash}`;
};
var CHAIN_EXPLORERS = {
  [_delegationdeployments.CHAIN_ID.mainnet]: "https://etherscan.io",
  [_delegationdeployments.CHAIN_ID.optimism]: "https://optimistic.etherscan.io",
  [_delegationdeployments.CHAIN_ID.polygon]: "https://polygonscan.com",
  [_delegationdeployments.CHAIN_ID.base]: "https://basescan.org",
  [_delegationdeployments.CHAIN_ID.arbitrum]: "https://arbiscan.io",
  [_delegationdeployments.CHAIN_ID.linea]: "https://lineascan.build",
  [_delegationdeployments.CHAIN_ID.sepolia]: "https://sepolia.etherscan.io",
  [_delegationdeployments.CHAIN_ID.lineaGoerli]: "https://goerli.lineascan.build",
  [_delegationdeployments.CHAIN_ID.lineaSepolia]: "https://sepolia.lineascan.build"
};
var getExplorerLink = (chainId) => {
  const url = CHAIN_EXPLORERS[chainId];
  if (!url) {
    throw new Error(`Unsupported chainId: ${chainId}`);
  }
  return url;
};
var shortenHash = (address) => !!address ? address.slice(0, 6) + "..." : "";
var getInfuraRpcUrl = (chainId, apiKey) => {
  if (!apiKey)
    throw new Error("Infura API key is required");
  switch (chainId) {
    case _delegationdeployments.CHAIN_ID.mainnet:
      return `https://mainnet.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.optimism:
      return `https://optimism-mainnet.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.polygon:
      return `https://polygon-mainnet.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.arbitrum:
      return `https://arbitrum-mainnet.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.linea:
      return `https://linea-mainnet.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.sepolia:
      return `https://sepolia.infura.io/v3/${apiKey}`;
    case _delegationdeployments.CHAIN_ID.lineaSepolia:
      return `https://linea-sepolia.infura.io/v3/${apiKey}`;
    default:
      throw new Error(`Unsupported chainId: ${chainId}`);
  }
};

// src/constants.ts
var Implementation = /* @__PURE__ */ ((Implementation2) => {
  Implementation2[Implementation2["MultiSig"] = 0] = "MultiSig";
  Implementation2[Implementation2["Hybrid"] = 1] = "Hybrid";
  return Implementation2;
})(Implementation || {});

// src/data.ts

function isEqualHex(a, b) {
  return _viem.isHex.call(void 0, a) && a.toLowerCase() === b.toLowerCase();
}
function deepHexlify(obj) {
  if (typeof obj === "function") {
    return void 0;
  }
  if (obj == null || typeof obj === "string" || typeof obj === "boolean") {
    return obj;
  }
  if (typeof obj === "bigint") {
    return _viem.toHex.call(void 0, obj);
  }
  if (obj._isBigNumber != null || typeof obj !== "object") {
    return _viem.toHex.call(void 0, obj).replace(/^0x0/, "0x");
  }
  if (Array.isArray(obj)) {
    return obj.map((member) => deepHexlify(member));
  }
  return Object.keys(obj).reduce(
    (set, key) => Object.assign(Object.assign({}, set), {
      [key]: deepHexlify(obj[key])
    }),
    {}
  );
}

// src/delegatorEnvironment.ts































// src/write.ts

var deployWithSimpleFactory = async (walletClient, publicClient, simpleFactoryAddress, creationCode, salt) => {
  const { request } = await publicClient.simulateContract({
    account: walletClient.account,
    address: simpleFactoryAddress,
    abi: _delegationabis.SimpleFactory.abi,
    functionName: "deploy",
    args: [creationCode, salt.toString(16)]
  });
  return await walletClient.writeContract(request);
};
var redeemDelegations = async (walletClient, publicClient, delegationManagerAddress, redemptions) => {
  if (redemptions.length === 0) {
    throw new Error(`RedeemDelegations invalid zero redemptions`);
  }
  const permissionContexts = [];
  const executionsBatch = [];
  const executionModes = [];
  redemptions.forEach((redemption) => {
    permissionContexts.push(redemption.permissionContext);
    executionsBatch.push(redemption.executions);
    executionModes.push(redemption.mode);
  });
  const encodedPermissionContexts = encodePermissionContexts(permissionContexts);
  const executionCalldatas = encodeExecutionCalldatas(executionsBatch);
  const { request } = await publicClient.simulateContract({
    account: walletClient.account,
    address: delegationManagerAddress,
    abi: _delegationabis.DelegationManager.abi,
    functionName: "redeemDelegations",
    args: [encodedPermissionContexts, executionModes, executionCalldatas]
  });
  return await walletClient.writeContract(request);
};
async function deployContract(walletClient, publicClient, chain, { bytecode, abi }, args = []) {
  const hash = await walletClient.deployContract({
    abi,
    bytecode,
    args,
    account: walletClient.account,
    chain
  });
  const receipt = await publicClient.waitForTransactionReceipt({
    hash
  });
  const address = (await receipt).contractAddress;
  return { address, hash, receipt };
}

// src/delegatorEnvironment.ts
var PREFERRED_VERSION = "1.2.0";
var contractOverrides = {
  "1.0.0": {},
  "1.1.0": {},
  "1.2.0": {}
};
function overrideDeployedEnvironment(chainId, version, environment) {
  contractOverrides[version][chainId] = environment;
}
function getDeleGatorEnvironment(chainId, version = PREFERRED_VERSION) {
  const override = contractOverrides[version][chainId];
  if (override) {
    return override;
  }
  const c = _optionalChain([_delegationdeployments.DELEGATOR_CONTRACTS, 'access', _3 => _3[version], 'optionalAccess', _4 => _4[chainId]]);
  if (!c) {
    throw new Error(
      `No contracts found for version ${version} chain ${chainId}`
    );
  }
  return getDeleGatorEnvironment_v1(c);
}
function getDeleGatorEnvironment_v1(c) {
  return {
    DelegationManager: c.DelegationManager,
    EntryPoint: c.EntryPoint,
    SimpleFactory: c.SimpleFactory,
    implementations: {
      MultiSigDeleGatorImpl: c.MultiSigDeleGatorImpl,
      HybridDeleGatorImpl: c.HybridDeleGatorImpl
    },
    caveatEnforcers: {
      AllowedCalldataEnforcer: c.AllowedCalldataEnforcer,
      AllowedMethodsEnforcer: c.AllowedMethodsEnforcer,
      AllowedTargetsEnforcer: c.AllowedTargetsEnforcer,
      ArgsEqualityCheckEnforcer: c.ArgsEqualityCheckEnforcer,
      BlockNumberEnforcer: c.BlockNumberEnforcer,
      DeployedEnforcer: c.DeployedEnforcer,
      ERC20BalanceGteEnforcer: c.ERC20BalanceGteEnforcer,
      ERC20TransferAmountEnforcer: c.ERC20TransferAmountEnforcer,
      ERC721BalanceGteEnforcer: c.ERC721BalanceGteEnforcer,
      ERC721TransferEnforcer: c.ERC721TransferEnforcer,
      ERC1155BalanceGteEnforcer: c.ERC1155BalanceGteEnforcer,
      IdEnforcer: c.IdEnforcer,
      LimitedCallsEnforcer: c.LimitedCallsEnforcer,
      NonceEnforcer: c.NonceEnforcer,
      TimestampEnforcer: c.TimestampEnforcer,
      ValueLteEnforcer: c.ValueLteEnforcer,
      NativeTokenTransferAmountEnforcer: c.NativeTokenTransferAmountEnforcer,
      NativeBalanceGteEnforcer: c.NativeBalanceGteEnforcer,
      NativeTokenPaymentEnforcer: c.NativeTokenPaymentEnforcer,
      OwnershipTransferEnforcer: c.OwnershipTransferEnforcer,
      RedeemerEnforcer: c.RedeemerEnforcer
    }
  };
}
async function deployDeleGatorEnvironment(walletClient, publicClient, chain, deployedContracts = {}) {
  const deployContractCurried = async (name, contract, params = []) => {
    if (deployedContracts[name]) {
      return {
        address: deployedContracts[name],
        name
      };
    }
    const deployedContract = await deployContract(
      walletClient,
      publicClient,
      chain,
      contract,
      params
    );
    deployedContracts[name] = deployedContract.address;
    return { ...deployedContract, name };
  };
  const standaloneContracts = {
    SimpleFactory: _delegationabis.SimpleFactory,
    AllowedCalldataEnforcer: _delegationabis.AllowedCalldataEnforcer,
    AllowedTargetsEnforcer: _delegationabis.AllowedTargetsEnforcer,
    AllowedMethodsEnforcer: _delegationabis.AllowedMethodsEnforcer,
    ArgsEqualityCheckEnforcer: _delegationabis.ArgsEqualityCheckEnforcer,
    DeployedEnforcer: _delegationabis.DeployedEnforcer,
    TimestampEnforcer: _delegationabis.TimestampEnforcer,
    BlockNumberEnforcer: _delegationabis.BlockNumberEnforcer,
    LimitedCallsEnforcer: _delegationabis.LimitedCallsEnforcer,
    ERC20BalanceGteEnforcer: _delegationabis.ERC20BalanceGteEnforcer,
    ERC20TransferAmountEnforcer: _delegationabis.ERC20TransferAmountEnforcer,
    ERC721BalanceGteEnforcer: _delegationabis.ERC721BalanceGteEnforcer,
    ERC721TransferEnforcer: _delegationabis.ERC721TransferEnforcer,
    ERC1155BalanceGteEnforcer: _delegationabis.ERC1155BalanceGteEnforcer,
    IdEnforcer: _delegationabis.IdEnforcer,
    NonceEnforcer: _delegationabis.NonceEnforcer,
    ValueLteEnforcer: _delegationabis.ValueLteEnforcer,
    NativeTokenTransferAmountEnforcer: _delegationabis.NativeTokenTransferAmountEnforcer,
    NativeBalanceGteEnforcer: _delegationabis.NativeBalanceGteEnforcer,
    OwnershipTransferEnforcer: _delegationabis.OwnershipTransferEnforcer,
    RedeemerEnforcer: _delegationabis.RedeemerEnforcer
  };
  for (const [name, contract] of Object.entries(standaloneContracts)) {
    await deployContractCurried(name, contract);
  }
  const delegationManager = await deployContractCurried(
    "DelegationManager",
    _delegationabis.DelegationManager,
    [_optionalChain([walletClient, 'access', _5 => _5.account, 'optionalAccess', _6 => _6.address])]
  );
  await deployContractCurried(
    "NativeTokenPaymentEnforcer",
    _delegationabis.NativeTokenPaymentEnforcer,
    [delegationManager.address, deployedContracts["ArgsEqualityCheckEnforcer"]]
  );
  const entryPoint = await deployContractCurried("EntryPoint", _delegationabis.EntryPoint);
  const { address: sclRIP7212 } = await deployContract(
    walletClient,
    publicClient,
    chain,
    _delegationabis.SCL_RIP7212,
    []
  );
  const hybridDeleGatorWithLinkedLibrary = {
    ..._delegationabis.HybridDeleGator,
    bytecode: _delegationabis.HybridDeleGator.bytecode.replace(
      /__\$b8f96b288d4d0429e38b8ed50fd423070f\$__/g,
      sclRIP7212.slice(2)
    )
  };
  await deployContractCurried(
    "HybridDeleGatorImpl",
    hybridDeleGatorWithLinkedLibrary,
    [delegationManager.address, entryPoint.address]
  );
  await deployContractCurried("MultiSigDeleGatorImpl", _delegationabis.MultiSigDeleGator, [
    delegationManager.address,
    entryPoint.address
  ]);
  return getDeleGatorEnvironment_v1(deployedContracts);
}

// src/rpcError.ts
var RpcError = (_class3 = class _RpcError extends Error {
  
  
  static __initStatic() {this.INVALID_PARAMETERS = -32602}
  static __initStatic2() {this.INTERNAL_ERROR = -32603}
  static __initStatic3() {this.METHOD_NOT_SUPPORTED = -32601}
  // implementation-defined server-error
  static __initStatic4() {this.CONNECTION_CLOSED = -32001}
  static from(error) {
    if (error instanceof _RpcError) {
      return error;
    }
    const errorMessage = error instanceof Error ? error.message : error;
    return new _RpcError(errorMessage, _RpcError.INTERNAL_ERROR);
  }
  toJSONRPCError() {
    const { message, code, data } = this;
    return {
      message,
      code,
      data
    };
  }
  constructor(message, code, data) {
    super(message);
    Object.setPrototypeOf(this, _RpcError.prototype);
    this.code = code;
    this.data = data;
  }
}, _class3.__initStatic(), _class3.__initStatic2(), _class3.__initStatic3(), _class3.__initStatic4(), _class3);

// src/userOp.ts








var createRawUserOp = (sender, nonce2, callData, signature = "0x", options) => ({
  sender,
  nonce: nonce2,
  callData,
  factory: _optionalChain([options, 'optionalAccess', _7 => _7.factory]),
  factoryData: _optionalChain([options, 'optionalAccess', _8 => _8.factoryData]),
  callGasLimit: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _9 => _9.callGasLimit]), () => ( 0n)),
  verificationGasLimit: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _10 => _10.verificationGasLimit]), () => ( 0n)),
  preVerificationGas: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _11 => _11.preVerificationGas]), () => ( 0n)),
  maxFeePerGas: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _12 => _12.maxFeePerGas]), () => ( 0n)),
  maxPriorityFeePerGas: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _13 => _13.maxPriorityFeePerGas]), () => ( 0n)),
  paymaster: _optionalChain([options, 'optionalAccess', _14 => _14.paymaster]),
  paymasterVerificationGasLimit: _optionalChain([options, 'optionalAccess', _15 => _15.paymasterVerificationGasLimit]),
  paymasterPostOpGasLimit: _optionalChain([options, 'optionalAccess', _16 => _16.paymasterPostOpGasLimit]),
  paymasterData: _optionalChain([options, 'optionalAccess', _17 => _17.paymasterData]),
  signature
});
var getSalt = (salt) => {
  if (!salt) {
    salt = "0x0";
  }
  return salt;
};
var getPaymasterAndData = (userOp) => {
  let paymasterAndData;
  if (userOp.paymaster) {
    paymasterAndData = _viem.concat.call(void 0, [
      userOp.paymaster,
      _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.paymasterVerificationGasLimit || 0n), {
        size: 16
      }),
      _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.paymasterPostOpGasLimit || 0n), {
        size: 16
      }),
      userOp.paymasterData || "0x"
    ]);
  } else {
    paymasterAndData = "0x";
  }
  return paymasterAndData;
};
var getInitCode = (userOp) => {
  return userOp.factory ? _viem.concat.call(void 0, [userOp.factory, _nullishCoalesce(userOp.factoryData, () => ( "0x"))]) : "0x";
};
var getAccountGasLimits = (userOp) => {
  return _viem.concat.call(void 0, [
    _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.verificationGasLimit), {
      size: 16
    }),
    _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.callGasLimit), { size: 16 })
  ]);
};
var getGasFees = (userOp) => {
  return _viem.concat.call(void 0, [
    _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.maxPriorityFeePerGas), {
      size: 16
    }),
    _viem.pad.call(void 0, _viem.toHex.call(void 0, userOp.maxFeePerGas), { size: 16 })
  ]);
};
var packUserOp = (userOp) => {
  const packedOp = {
    sender: userOp.sender,
    nonce: BigInt(userOp.nonce),
    initCode: getInitCode(userOp),
    callData: userOp.callData,
    accountGasLimits: getAccountGasLimits(userOp),
    preVerificationGas: BigInt(userOp.preVerificationGas),
    gasFees: getGasFees(userOp),
    paymasterAndData: getPaymasterAndData(userOp),
    signature: userOp.signature
  };
  return packedOp;
};
var formatDelegationForSigning = (delegation) => {
  const caveats = delegation.caveats.map((caveat) => ({
    enforcer: _viem.getAddress.call(void 0, caveat.enforcer),
    terms: caveat.terms,
    args: caveat.args
  }));
  return {
    delegate: _viem.getAddress.call(void 0, delegation.delegate),
    delegator: _viem.getAddress.call(void 0, delegation.delegator),
    authority: delegation.authority === void 0 ? ROOT_AUTHORITY : delegation.authority,
    caveats,
    salt: delegation.salt
  };
};
var createUserOpHashV07 = (packedOp, entryPoint, chainId) => {
  const hash = _viem.keccak256.call(void 0, 
    _viem.encodeAbiParameters.call(void 0, 
      [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "nonce",
          type: "uint256"
        },
        {
          name: "initCodeHash",
          type: "bytes32"
        },
        {
          name: "callDataHash",
          type: "bytes32"
        },
        {
          name: "accountGasLimits",
          type: "bytes32"
        },
        {
          name: "preVerificationGas",
          type: "uint256"
        },
        {
          name: "gasFees",
          type: "bytes32"
        },
        {
          name: "paymasterAndDataHash",
          type: "bytes32"
        }
      ],
      [
        packedOp.sender,
        packedOp.nonce,
        _viem.keccak256.call(void 0, packedOp.initCode),
        _viem.keccak256.call(void 0, packedOp.callData),
        packedOp.accountGasLimits,
        packedOp.preVerificationGas,
        packedOp.gasFees,
        _viem.keccak256.call(void 0, packedOp.paymasterAndData)
      ]
    )
  );
  return _viem.keccak256.call(void 0, 
    _viem.encodeAbiParameters.call(void 0, 
      [
        {
          name: "userOpHash",
          type: "bytes32"
        },
        {
          name: "entryPointAddress",
          type: "address"
        },
        {
          name: "chainId",
          type: "uint256"
        }
      ],
      [hash, entryPoint, chainId]
    )
  );
};
var SIGNABLE_USER_OP_TYPED_DATA = {
  PackedUserOperation: [
    { name: "sender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "initCode", type: "bytes" },
    { name: "callData", type: "bytes" },
    { name: "accountGasLimits", type: "bytes32" },
    { name: "preVerificationGas", type: "uint256" },
    { name: "gasFees", type: "bytes32" },
    { name: "paymasterAndData", type: "bytes" }
  ]
};

// src/webAuthn.ts
var _webauthnp256 = require('webauthn-p256');







var FIELD_MODULUS = 115792089210356248762697446949407573529996955224135760342422259061068512044369n;
var MALLEABILITY_THRESHOLD = FIELD_MODULUS / 2n;
var SIGNATURE_ABI_PARAMS = _viem.parseAbiParameters.call(void 0, 
  "bytes32, uint256, uint256, bytes, bool, string, string, uint256"
);
var splitOnChallenge = (clientDataJson) => {
  try {
    const { challenge } = JSON.parse(clientDataJson);
    if (challenge === void 0) {
      throw new Error('No "challenge" found in the input string');
    }
    return clientDataJson.split(challenge);
  } catch (error) {
    throw new Error('No "challenge" found in the input string', {
      cause: error
    });
  }
};
var getResponseTypeLocation = (clientDataJson) => {
  try {
    const typeIndex = clientDataJson.indexOf('"type":');
    if (typeIndex === -1)
      throw new Error('No "type" found in the input string');
    return BigInt(typeIndex);
  } catch (error) {
    throw new Error('No "type" found in the input string', {
      cause: error
    });
  }
};
function encodeDeleGatorSignature(keyId, signature, clientDataJSON, authenticatorData) {
  const keyIdHash = _viem.keccak256.call(void 0, _viem.encodePacked.call(void 0, ["string"], [keyId]));
  let { r, s } = _webauthnp256.parseSignature.call(void 0, signature);
  while (s > MALLEABILITY_THRESHOLD) {
    s = FIELD_MODULUS - s;
  }
  const [clientDataComponent1, clientDataComponent2] = splitOnChallenge(clientDataJSON);
  const { userVerified } = parseAuthenticatorFlags(authenticatorData);
  const responseTypeLocation = getResponseTypeLocation(clientDataJSON);
  const encodedSignature = _viem.encodeAbiParameters.call(void 0, SIGNATURE_ABI_PARAMS, [
    keyIdHash,
    r,
    s,
    authenticatorData,
    userVerified,
    clientDataComponent1,
    clientDataComponent2,
    responseTypeLocation
  ]);
  return encodedSignature;
}
var AUTHENTICATOR_DATA_FLAGS_OFFSET = 32;
function parseAuthenticatorFlags(authenticatorData) {
  const authenticatorDataBuffer = Buffer.from(
    authenticatorData.slice(2),
    "hex"
  );
  const flags = authenticatorDataBuffer.readUInt8(
    AUTHENTICATOR_DATA_FLAGS_OFFSET
  );
  const bitMask = 1 << 2 /* USER_VERIFIED */;
  return {
    userVerified: (flags & bitMask) !== 0
  };
}
var createDummyWebAuthnSignature = (keyId) => {
  const rpIdHash = _viem.keccak256.call(void 0, _viem.encodePacked.call(void 0, ["string"], ["AuthenticatorData"]));
  const flags = "0x05";
  const signCount = "0x00000000";
  const authenticatorData = _viem.concat.call(void 0, [rpIdHash, flags, signCount]);
  const keyIdHash = _viem.keccak256.call(void 0, _viem.encodePacked.call(void 0, ["string"], [keyId]));
  const rs = 57896044605178124381348723474703786764998477612067880171211129530534256022184n;
  const userVerification = true;
  const clientDataPrefix = '{"type":"webauthn.get","challenge":"';
  const clientDataSuffix = '","origin":"passkey-domain","crossOrigin":false}';
  const responseTypeLocation = 1n;
  const encodedSignature = _viem.encodeAbiParameters.call(void 0, SIGNATURE_ABI_PARAMS, [
    keyIdHash,
    rs,
    rs,
    authenticatorData,
    userVerification,
    clientDataPrefix,
    clientDataSuffix,
    responseTypeLocation
  ]);
  return encodedSignature;
};








































































exports.ANY_BENEFICIARY = ANY_BENEFICIARY; exports.BATCH_DEFAULT_MODE = BATCH_DEFAULT_MODE; exports.BATCH_TRY_MODE = BATCH_TRY_MODE; exports.CAVEAT_ABI_TYPE_COMPONENTS = CAVEAT_ABI_TYPE_COMPONENTS; exports.CAVEAT_TYPEHASH = CAVEAT_TYPEHASH; exports.CaveatBuilder = CaveatBuilder; exports.DELEGATION_ABI_TYPE_COMPONENTS = DELEGATION_ABI_TYPE_COMPONENTS; exports.DELEGATION_ARRAY_ABI_TYPE = DELEGATION_ARRAY_ABI_TYPE; exports.DELEGATION_TYPEHASH = DELEGATION_TYPEHASH; exports.DelegationStorageClient = DelegationStorageClient; exports.DelegationStorageEnvironment = DelegationStorageEnvironment; exports.DelegationStoreFilter = DelegationStoreFilter; exports.EXECUTION_ABI_TYPE_COMPONENTS = EXECUTION_ABI_TYPE_COMPONENTS; exports.FIELD_MODULUS = FIELD_MODULUS; exports.Implementation = Implementation; exports.MALLEABILITY_THRESHOLD = MALLEABILITY_THRESHOLD; exports.PREFERRED_VERSION = PREFERRED_VERSION; exports.ROOT_AUTHORITY = ROOT_AUTHORITY; exports.RpcError = RpcError; exports.SIGNABLE_DELEGATION_TYPED_DATA = SIGNABLE_DELEGATION_TYPED_DATA; exports.SIGNABLE_USER_OP_TYPED_DATA = SIGNABLE_USER_OP_TYPED_DATA; exports.SIGNATURE_ABI_PARAMS = SIGNATURE_ABI_PARAMS; exports.SINGLE_DEFAULT_MODE = SINGLE_DEFAULT_MODE; exports.SINGLE_TRY_MODE = SINGLE_TRY_MODE; exports.createCaveat = createCaveat; exports.createCaveatBuilder = createCaveatBuilder; exports.createDelegation = createDelegation; exports.createDummyWebAuthnSignature = createDummyWebAuthnSignature; exports.createExecution = createExecution; exports.createOpenDelegation = createOpenDelegation; exports.createOpenRootDelegation = createOpenRootDelegation; exports.createRawUserOp = createRawUserOp; exports.createRootDelegation = createRootDelegation; exports.createUserOpHashV07 = createUserOpHashV07; exports.deepHexlify = deepHexlify; exports.deployContract = deployContract; exports.deployDeleGatorEnvironment = deployDeleGatorEnvironment; exports.deployWithSimpleFactory = deployWithSimpleFactory; exports.encodeBatchExecution = encodeBatchExecution; exports.encodeDeleGatorSignature = encodeDeleGatorSignature; exports.encodeDelegation = encodeDelegation; exports.encodeDelegations = encodeDelegations; exports.encodeExecutionCalldata = encodeExecutionCalldata; exports.encodeExecutionCalldatas = encodeExecutionCalldatas; exports.encodePermissionContexts = encodePermissionContexts; exports.encodeSingleExecution = encodeSingleExecution; exports.formatDelegationForSigning = formatDelegationForSigning; exports.getAccountGasLimits = getAccountGasLimits; exports.getCaveatArrayPacketHash = getCaveatArrayPacketHash; exports.getCaveatPacketHash = getCaveatPacketHash; exports.getDeleGatorEnvironment = getDeleGatorEnvironment; exports.getDeleGatorEnvironment_v1 = getDeleGatorEnvironment_v1; exports.getDelegationHashOffchain = getDelegationHashOffchain; exports.getExplorerAddressLink = getExplorerAddressLink; exports.getExplorerTransactionLink = getExplorerTransactionLink; exports.getGasFees = getGasFees; exports.getInfuraRpcUrl = getInfuraRpcUrl; exports.getInitCode = getInitCode; exports.getPaymasterAndData = getPaymasterAndData; exports.getResponseTypeLocation = getResponseTypeLocation; exports.getSalt = getSalt; exports.isEqualHex = isEqualHex; exports.overrideDeployedEnvironment = overrideDeployedEnvironment; exports.packUserOp = packUserOp; exports.parseAuthenticatorFlags = parseAuthenticatorFlags; exports.prepDelegationHashForPasskeySign = prepDelegationHashForPasskeySign; exports.redeemDelegations = redeemDelegations; exports.resolveCaveats = resolveCaveats; exports.shortenHash = shortenHash; exports.signDelegation = signDelegation; exports.splitOnChallenge = splitOnChallenge;
//# sourceMappingURL=index.js.map