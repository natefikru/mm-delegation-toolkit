// src/index.ts
export * from "@metamask-private/delegation-deployments";
export * from "@metamask-private/delegation-abis";

// src/delegationStorage.ts
import { toHex as toHex13 } from "viem";

// src/delegation.ts
import {
  encodeAbiParameters as encodeAbiParameters2,
  parseAbiParameters as parseAbiParameters2,
  keccak256 as keccak2562,
  hashMessage,
  toBytes,
  toHex as toHex12
} from "viem";

// src/caveats.ts
import {
  encodePacked,
  encodeAbiParameters,
  parseAbiParameters,
  keccak256,
  toHex
} from "viem";
var CAVEAT_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "enforcer" },
  { type: "bytes", name: "terms" },
  { type: "bytes", name: "args" }
];
var CAVEAT_TYPEHASH = keccak256(
  toHex("Caveat(address enforcer,bytes terms)")
);
var getCaveatArrayPacketHash = (input) => {
  let encoded = "0x";
  for (let i = 0; i < input.length; ++i) {
    const caveatPacketHash = getCaveatPacketHash(input[i]);
    encoded = encodePacked(["bytes", "bytes32"], [encoded, caveatPacketHash]);
  }
  return keccak256(encoded);
};
var getCaveatPacketHash = (input) => {
  const encoded = encodeAbiParameters(
    parseAbiParameters("bytes32, address, bytes32"),
    [CAVEAT_TYPEHASH, input.enforcer, keccak256(input.terms)]
  );
  return keccak256(encoded);
};
var createCaveat = (enforcer, terms, args = "0x") => ({
  enforcer,
  terms,
  args
});

// src/caveatBuilder/allowedMethodsBuilder.ts
import { isHex, concat, toFunctionSelector } from "viem";
var allowedMethods = "allowedMethods";
var FUNCTION_SELECTOR_STRING_LENGTH = 10;
var allowedMethodsBuilder = (environment, selectors) => {
  if (selectors.length === 0) {
    throw new Error("Invalid selectors: must provide at least one selector");
  }
  const parsedSelectors = selectors.map(parseSelector);
  const terms = concat(parsedSelectors);
  const {
    caveatEnforcers: { AllowedMethodsEnforcer: AllowedMethodsEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedMethodsEnforcer2,
    terms,
    args: "0x"
  };
};
function parseSelector(selector) {
  if (isHex(selector)) {
    if (selector.length !== FUNCTION_SELECTOR_STRING_LENGTH) {
      throw new Error(
        "Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction"
      );
    } else {
      return selector;
    }
  }
  try {
    return toFunctionSelector(selector);
  } catch (rootError) {
    throw new Error(
      "Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction",
      { cause: rootError }
    );
  }
}

// src/caveatBuilder/allowedTargetsBuilder.ts
import { concat as concat2, isAddress } from "viem";
var allowedTargets = "allowedTargets";
var allowedTargetsBuilder = (environment, targets) => {
  if (targets.length === 0) {
    throw new Error(
      "Invalid targets: must provide at least one target address"
    );
  }
  const invalidAddresses = targets.filter(
    (target) => !isAddress(target, { strict: false })
  );
  if (invalidAddresses.length > 0) {
    throw new Error("Invalid targets: must be valid addresses");
  }
  const terms = concat2(targets);
  const {
    caveatEnforcers: { AllowedTargetsEnforcer: AllowedTargetsEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedTargetsEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/caveatBuilder.ts
var resolveCaveats = (caveats) => {
  if (Array.isArray(caveats)) {
    return caveats;
  }
  return caveats.build();
};
var CaveatBuilder = class _CaveatBuilder {
  constructor(environment, config = {}, enforcerBuilders = {}, builtCaveats = []) {
    this.environment = environment;
    this.config = config;
    this.enforcerBuilders = enforcerBuilders;
    this.results = builtCaveats;
  }
  results = [];
  hasBeenBuilt = false;
  /**
   * Extends the CaveatBuilder with a new enforcer function.
   *
   * @template TEnforcerName - The name of the enforcer.
   * @template TFunction - The type of the enforcer function.
   * @param name - The name of the enforcer.
   * @param fn - The enforcer function.
   * @returns The extended CaveatBuilder instance.
   */
  extend(name, fn) {
    return new _CaveatBuilder(
      this.environment,
      this.config,
      { ...this.enforcerBuilders, [name]: fn },
      this.results
    );
  }
  /**
   * Adds a caveat to the CaveatBuilder instance.
   *
   * The function modifies the caveats represented by the current CaveatBuilder
   * instance, but also returns the CaveatBuilder instance to facilitate call
   * chaining.
   *
   * @template TEnforcerName - The type of the enforcer name.
   * @param name - The name of the enforcer.
   * @param args - The arguments for the enforcer function.
   * @returns The CaveatBuilder instance.
   * @throws If the specified enforcer function does not exist.
   */
  addCaveat(name, ...args) {
    const func = this.enforcerBuilders[name];
    if (typeof func === "function") {
      const result = func(this.environment, ...args);
      this.results = [...this.results, result];
      return this;
    }
    throw new Error(`Function "${String(name)}" does not exist.`);
  }
  /**
   * Returns the caveats that have been built using this CaveatBuilder.
   *
   * @returns The array of built caveats.
   */
  build() {
    if (this.hasBeenBuilt) {
      throw new Error("This CaveatBuilder has already been built.");
    }
    if (this.results.length === 0 && !this.config.allowEmptyCaveats) {
      throw new Error(
        "No caveats found. If you definitely want to create an empty caveat collection, set `allowEmptyCaveats`."
      );
    }
    this.hasBeenBuilt = true;
    return this.results;
  }
};

// src/caveatBuilder/deployedBuilder.ts
import { concat as concat3, isAddress as isAddress2, isHex as isHex2, pad } from "viem";
var deployed = "deployed";
var deployedBuilder = (environment, contractAddress, salt, bytecode) => {
  if (!isAddress2(contractAddress, { strict: false })) {
    throw new Error(
      `Invalid contractAddress: must be a valid Ethereum address`
    );
  }
  if (!isHex2(salt)) {
    throw new Error("Invalid salt: must be a valid hexadecimal string");
  }
  if (!isHex2(bytecode)) {
    throw new Error("Invalid bytecode: must be a valid hexadecimal string");
  }
  const terms = concat3([contractAddress, pad(salt, { size: 32 }), bytecode]);
  const {
    caveatEnforcers: { DeployedEnforcer: DeployedEnforcer2 }
  } = environment;
  return {
    enforcer: DeployedEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/allowedCalldataBuilder.ts
import { concat as concat4, isHex as isHex3, toHex as toHex2 } from "viem";
var allowedCalldata = "allowedCalldata";
var allowedCalldataBuilder = (environment, startIndex, value) => {
  if (!isHex3(value)) {
    throw new Error("Invalid value: must be a valid hex string");
  }
  if (startIndex < 0) {
    throw new Error("Invalid startIndex: must be zero or positive");
  }
  if (!Number.isInteger(startIndex)) {
    throw new Error("Invalid startIndex: must be a whole number");
  }
  const startIndexHex = toHex2(startIndex, { size: 32 });
  const terms = concat4([startIndexHex, value]);
  const {
    caveatEnforcers: { AllowedCalldataEnforcer: AllowedCalldataEnforcer2 }
  } = environment;
  return {
    enforcer: AllowedCalldataEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20BalanceGteBuilder.ts
import { isAddress as isAddress3, encodePacked as encodePacked2 } from "viem";
var erc20BalanceGte = "erc20BalanceGte";
var erc20BalanceGteBuilder = (environment, tokenAddress, balance) => {
  if (!isAddress3(tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  const terms = encodePacked2(["address", "uint256"], [tokenAddress, balance]);
  const {
    caveatEnforcers: { ERC20BalanceGteEnforcer: ERC20BalanceGteEnforcer2 }
  } = environment;
  return {
    enforcer: ERC20BalanceGteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/valueLteBuilder.ts
import { concat as concat5, toHex as toHex3 } from "viem";
var valueLte = "valueLte";
var valueLteBuilder = (environment, maxValue) => {
  if (maxValue < 0n) {
    throw new Error("Invalid maxValue: must be greater than zero");
  }
  const terms = concat5([toHex3(maxValue, { size: 32 })]);
  const {
    caveatEnforcers: { ValueLteEnforcer: ValueLteEnforcer2 }
  } = environment;
  return {
    enforcer: ValueLteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/limitedCallsBuilder.ts
import { toHex as toHex4, pad as pad2 } from "viem";
var limitedCalls = "limitedCalls";
var limitedCallsBuilder = (environment, limit) => {
  if (!Number.isInteger(limit)) {
    throw new Error("Invalid limit: must be an integer");
  }
  if (limit <= 0) {
    throw new Error("Invalid limit: must be a positive integer");
  }
  const terms = pad2(toHex4(limit), { size: 32 });
  const {
    caveatEnforcers: { LimitedCallsEnforcer: LimitedCallsEnforcer2 }
  } = environment;
  return {
    enforcer: LimitedCallsEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/idBuilder.ts
import { toHex as toHex5 } from "viem";
var id = "id";
var idBuilder = (environment, id2) => {
  if (typeof id2 !== "number") {
    throw new Error("Invalid id: must be a number");
  }
  if (!Number.isInteger(id2)) {
    throw new Error("Invalid id: must be an integer");
  }
  if (id2 >= 2 ** 32) {
    throw new Error("Invalid id: must be 32 bytes or fewer in length");
  }
  const terms = toHex5(id2, { size: 32 });
  const {
    caveatEnforcers: { IdEnforcer: IdEnforcer2 }
  } = environment;
  return {
    enforcer: IdEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nonceBuilder.ts
import { isHex as isHex4, pad as pad3 } from "viem";
var nonce = "nonce";
var MAX_NONCE_STRING_LENGTH = 66;
var nonceBuilder = (environment, nonce2) => {
  if (!nonce2 || nonce2 === "0x") {
    throw new Error("Invalid nonce: must be a non-empty hex string");
  }
  if (!isHex4(nonce2)) {
    throw new Error("Invalid nonce: must be a valid hex string");
  }
  if (nonce2.length > MAX_NONCE_STRING_LENGTH) {
    throw new Error("Invalid nonce: must be 32 bytes or less in length");
  }
  const {
    caveatEnforcers: { NonceEnforcer: NonceEnforcer2 }
  } = environment;
  return {
    enforcer: NonceEnforcer2,
    terms: pad3(nonce2, { size: 32 }),
    args: "0x"
  };
};

// src/caveatBuilder/timestampBuilder.ts
import { concat as concat6, toHex as toHex6 } from "viem";
var timestamp = "timestamp";
var timestampBuilder = (environment, timestampAfterThreshold, timestampBeforeThreshold) => {
  if (timestampAfterThreshold < 0) {
    throw new Error(
      "Invalid timestampAfterThreshold: must be zero or positive"
    );
  }
  if (timestampBeforeThreshold < 0) {
    throw new Error(
      "Invalid timestampBeforeThreshold: must be zero or positive"
    );
  }
  if (timestampBeforeThreshold !== 0 && timestampAfterThreshold >= timestampBeforeThreshold) {
    throw new Error(
      "Invalid thresholds: timestampBeforeThreshold must be greater than timestampAfterThreshold when both are specified"
    );
  }
  const afterThresholdHex = toHex6(timestampAfterThreshold, { size: 16 });
  const beforeThresholdHex = toHex6(timestampBeforeThreshold, { size: 16 });
  const terms = concat6([afterThresholdHex, beforeThresholdHex]);
  const {
    caveatEnforcers: { TimestampEnforcer: TimestampEnforcer2 }
  } = environment;
  return {
    enforcer: TimestampEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/blockNumberBuilder.ts
import { concat as concat7, toHex as toHex7 } from "viem";
var blockNumber = "blockNumber";
var blockNumberBuilder = (environment, blockAfterThreshold, blockBeforeThreshold) => {
  if (blockAfterThreshold === 0n && blockBeforeThreshold === 0n) {
    throw new Error(
      "Invalid thresholds: At least one of blockAfterThreshold or blockBeforeThreshold must be specified"
    );
  }
  if (blockBeforeThreshold !== 0n && blockAfterThreshold >= blockBeforeThreshold) {
    throw new Error(
      "Invalid thresholds: blockAfterThreshold must be less than blockBeforeThreshold if both are specified"
    );
  }
  const terms = concat7([
    toHex7(blockAfterThreshold, {
      size: 16
    }),
    toHex7(blockBeforeThreshold, {
      size: 16
    })
  ]);
  const {
    caveatEnforcers: { BlockNumberEnforcer: BlockNumberEnforcer2 }
  } = environment;
  return {
    enforcer: BlockNumberEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc20TransferAmountBuilder.ts
import { concat as concat8, isAddress as isAddress4, toHex as toHex8 } from "viem";
var erc20TransferAmount = "erc20TransferAmount";
var erc20TransferAmountBuilder = (environment, tokenAddress, maxAmount) => {
  if (!isAddress4(tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (maxAmount <= 0n) {
    throw new Error("Invalid maxAmount: must be a positive number");
  }
  const terms = concat8([tokenAddress, toHex8(maxAmount, { size: 32 })]);
  const {
    caveatEnforcers: { ERC20TransferAmountEnforcer: ERC20TransferAmountEnforcer2 }
  } = environment;
  return {
    enforcer: ERC20TransferAmountEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenTransferAmountBuilder.ts
import { encodePacked as encodePacked3 } from "viem";
var nativeTokenTransferAmount = "nativeTokenTransferAmount";
var nativeTokenTransferAmountBuilder = (environment, allowance) => {
  if (allowance < 0n) {
    throw new Error("Invalid allowance: must be zero or positive");
  }
  const terms = encodePacked3(["uint256"], [allowance]);
  const {
    caveatEnforcers: { NativeTokenTransferAmountEnforcer: NativeTokenTransferAmountEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenTransferAmountEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeBalanceGteBuilder.ts
import { encodePacked as encodePacked4, isAddress as isAddress5 } from "viem";
var nativeBalanceGte = "nativeBalanceGte";
var nativeBalanceGteBuilder = (environment, recipient, balance) => {
  if (!isAddress5(recipient)) {
    throw new Error("Invalid recipient: must be a valid Address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  const terms = encodePacked4(["address", "uint256"], [recipient, balance]);
  const {
    caveatEnforcers: { NativeBalanceGteEnforcer: NativeBalanceGteEnforcer2 }
  } = environment;
  return {
    enforcer: NativeBalanceGteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/redeemerBuilder.ts
import { concat as concat9, isAddress as isAddress6 } from "viem";
var redeemer = "redeemer";
var redeemerBuilder = (environment, redeemers) => {
  if (redeemers.length === 0) {
    throw new Error(
      "Invalid redeemers: must specify at least one redeemer address"
    );
  }
  for (let i = 0; i < redeemers.length; i++) {
    if (!isAddress6(redeemers[i])) {
      throw new Error("Invalid redeemers: must be a valid address");
    }
  }
  const terms = concat9(redeemers);
  const {
    caveatEnforcers: { RedeemerEnforcer: RedeemerEnforcer2 }
  } = environment;
  return {
    enforcer: RedeemerEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/nativeTokenPaymentBuilder.ts
import { encodePacked as encodePacked5, isAddress as isAddress7 } from "viem";
var nativeTokenPayment = "nativeTokenPayment";
var nativeTokenPaymentBuilder = (environment, recipient, amount) => {
  if (amount <= 0n) {
    throw new Error("Invalid amount: must be positive");
  }
  if (!isAddress7(recipient)) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  const terms = encodePacked5(["address", "uint256"], [recipient, amount]);
  const {
    caveatEnforcers: { NativeTokenPaymentEnforcer: NativeTokenPaymentEnforcer2 }
  } = environment;
  return {
    enforcer: NativeTokenPaymentEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/argsEqualityCheckBuilder.ts
import { isHex as isHex5 } from "viem";
var argsEqualityCheck = "argsEqualityCheck";
var argsEqualityCheckBuilder = (environment, args) => {
  if (!isHex5(args)) {
    throw new Error("Invalid args: must be a valid hex string");
  }
  const terms = args;
  const {
    caveatEnforcers: { ArgsEqualityCheckEnforcer: ArgsEqualityCheckEnforcer2 }
  } = environment;
  return {
    enforcer: ArgsEqualityCheckEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc1155BalanceGteBuilder.ts
import { isAddress as isAddress8, concat as concat10, toHex as toHex9 } from "viem";
var erc1155BalanceGte = "erc1155BalanceGte";
var erc1155BalanceGteBuilder = (environment, tokenAddress, recipient, tokenId, balance) => {
  if (!isAddress8(tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (!isAddress8(recipient, { strict: false })) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  if (balance <= 0n) {
    throw new Error("Invalid balance: must be a positive number");
  }
  if (tokenId < 0) {
    throw new Error("Invalid tokenId: must be a non-negative number");
  }
  const terms = concat10([
    tokenAddress,
    recipient,
    toHex9(tokenId, { size: 32 }),
    toHex9(balance, { size: 32 })
  ]);
  const {
    caveatEnforcers: { ERC1155BalanceGteEnforcer: ERC1155BalanceGteEnforcer2 }
  } = environment;
  return {
    enforcer: ERC1155BalanceGteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc721BalanceGteBuilder.ts
import { isAddress as isAddress9, toHex as toHex10, concat as concat11 } from "viem";
var erc721BalanceGte = "erc721BalanceGte";
var erc721BalanceGteBuilder = (environment, tokenAddress, recipient, amount) => {
  if (!isAddress9(tokenAddress, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (!isAddress9(recipient, { strict: false })) {
    throw new Error("Invalid recipient: must be a valid address");
  }
  if (amount <= 0) {
    throw new Error("Invalid balance: must be a positive number");
  }
  const terms = concat11([tokenAddress, recipient, toHex10(amount, { size: 32 })]);
  const {
    caveatEnforcers: { ERC721BalanceGteEnforcer: ERC721BalanceGteEnforcer2 }
  } = environment;
  return {
    enforcer: ERC721BalanceGteEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/erc721TransferBuilder.ts
import { isAddress as isAddress10, toHex as toHex11, concat as concat12 } from "viem";
var erc721Transfer = "erc721Transfer";
var erc721TransferBuilder = (environment, permittedContract, permittedTokenId) => {
  if (!isAddress10(permittedContract, { strict: false })) {
    throw new Error("Invalid tokenAddress: must be a valid address");
  }
  if (permittedTokenId < 0) {
    throw new Error("Invalid permittedTokenId: must be a non-negative number");
  }
  const terms = concat12([
    permittedContract,
    toHex11(permittedTokenId, { size: 32 })
  ]);
  const {
    caveatEnforcers: { ERC721TransferEnforcer: ERC721TransferEnforcer2 }
  } = environment;
  return {
    enforcer: ERC721TransferEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/ownershipTransferBuilder.ts
import { isAddress as isAddress11 } from "viem";
var ownershipTransfer = "ownershipTransfer";
var ownershipTransferBuilder = (environment, targetContract) => {
  if (!isAddress11(targetContract, { strict: false })) {
    throw new Error("Invalid targetContract: must be a valid address");
  }
  const terms = targetContract;
  const {
    caveatEnforcers: { OwnershipTransferEnforcer: OwnershipTransferEnforcer2 }
  } = environment;
  return {
    enforcer: OwnershipTransferEnforcer2,
    terms,
    args: "0x"
  };
};

// src/caveatBuilder/index.ts
var createCaveatBuilder = (environment, config) => {
  const caveatBuilder = new CaveatBuilder(environment, config).extend(allowedMethods, allowedMethodsBuilder).extend(allowedTargets, allowedTargetsBuilder).extend(deployed, deployedBuilder).extend(allowedCalldata, allowedCalldataBuilder).extend(erc20BalanceGte, erc20BalanceGteBuilder).extend(erc721BalanceGte, erc721BalanceGteBuilder).extend(erc1155BalanceGte, erc1155BalanceGteBuilder).extend(valueLte, valueLteBuilder).extend(limitedCalls, limitedCallsBuilder).extend(id, idBuilder).extend(nonce, nonceBuilder).extend(timestamp, timestampBuilder).extend(blockNumber, blockNumberBuilder).extend(erc20TransferAmount, erc20TransferAmountBuilder).extend(erc721Transfer, erc721TransferBuilder).extend(nativeTokenTransferAmount, nativeTokenTransferAmountBuilder).extend(nativeBalanceGte, nativeBalanceGteBuilder).extend(redeemer, redeemerBuilder).extend(nativeTokenPayment, nativeTokenPaymentBuilder).extend(argsEqualityCheck, argsEqualityCheckBuilder).extend(ownershipTransfer, ownershipTransferBuilder);
  return caveatBuilder;
};

// src/delegation.ts
var encodeDelegation = (delegations) => {
  return encodeAbiParameters2(
    [
      {
        components: DELEGATION_ABI_TYPE_COMPONENTS,
        name: "delegations",
        type: "tuple[]"
      }
    ],
    [delegations]
  );
};
var encodePermissionContexts = (permissionContexts) => {
  const encodedDelegations = permissionContexts.map(
    (delegationChain) => encodeDelegation(delegationChain)
  );
  return encodedDelegations;
};
var ROOT_AUTHORITY = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
var ANY_BENEFICIARY = "0x0000000000000000000000000000000000000a11";
var DELEGATION_TYPEHASH = keccak2562(
  toHex12(
    "Delegation(address delegate,address delegator,bytes32 authority,Caveat[] caveats,uint256 salt)Caveat(address enforcer,bytes terms)"
  )
);
var DELEGATION_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "delegate" },
  { type: "address", name: "delegator" },
  { type: "bytes32", name: "authority" },
  { type: "tuple[]", name: "caveats", components: CAVEAT_ABI_TYPE_COMPONENTS },
  { type: "uint256", name: "salt" },
  { type: "bytes", name: "signature" }
];
var SIGNABLE_DELEGATION_TYPED_DATA = {
  Caveat: [
    { name: "enforcer", type: "address" },
    { name: "terms", type: "bytes" }
  ],
  Delegation: [
    { name: "delegate", type: "address" },
    { name: "delegator", type: "address" },
    { name: "authority", type: "bytes32" },
    { name: "caveats", type: "Caveat[]" },
    { name: "salt", type: "uint256" }
  ]
};
var DELEGATION_ARRAY_ABI_TYPE = {
  type: "tuple[]",
  components: DELEGATION_ABI_TYPE_COMPONENTS
};
var encodeDelegations = (delegations) => encodeAbiParameters2([DELEGATION_ARRAY_ABI_TYPE], [delegations]);
var prepDelegationHashForPasskeySign = (delegationHash) => {
  return hashMessage({
    raw: toBytes(delegationHash)
  });
};
var getDelegationHashOffchain = (input) => {
  const encoded = encodeAbiParameters2(
    parseAbiParameters2("bytes32, address, address, bytes32, bytes32, uint"),
    [
      DELEGATION_TYPEHASH,
      input.delegate,
      input.delegator,
      input.authority,
      getCaveatArrayPacketHash(input.caveats),
      input.salt
    ]
  );
  return keccak2562(encoded);
};
var createDelegation = (delegate, delegator, authority, caveats, salt = 0n) => ({
  delegate,
  delegator,
  authority,
  caveats: resolveCaveats(caveats),
  salt,
  signature: "0x"
});
var createOpenDelegation = (delegator, authority, caveats, salt) => createDelegation(ANY_BENEFICIARY, delegator, authority, caveats, salt);
var createRootDelegation = (delegate, delegator, caveats, salt) => createDelegation(delegate, delegator, ROOT_AUTHORITY, caveats, salt);
var createOpenRootDelegation = (delegator, caveats, salt) => createDelegation(ANY_BENEFICIARY, delegator, ROOT_AUTHORITY, caveats, salt);
var signDelegation = async (signer, delegation, delegationManager, chainId, name = "DelegationManager", version = "1") => signer.signTypedData({
  account: signer.account,
  domain: {
    chainId,
    name,
    version,
    verifyingContract: delegationManager
  },
  types: SIGNABLE_DELEGATION_TYPED_DATA,
  primaryType: "Delegation",
  message: delegation
});

// src/types.ts
var DelegationStoreFilter = /* @__PURE__ */ ((DelegationStoreFilter2) => {
  DelegationStoreFilter2["Given"] = "GIVEN";
  DelegationStoreFilter2["Received"] = "RECEIVED";
  DelegationStoreFilter2["All"] = "ALL";
  return DelegationStoreFilter2;
})(DelegationStoreFilter || {});

// src/delegationStorage.ts
var DelegationStorageEnvironment = {
  dev: { apiUrl: "https://passkeys.dev-api.cx.metamask.io" },
  prod: { apiUrl: "https://passkeys.api.cx.metamask.io" }
};
var DelegationStorageClient = class {
  _apiVersionPrefix = "api/v0";
  _config;
  _fetcher;
  _apiUrl;
  constructor(config) {
    let apiUrl = config.environment.apiUrl.replace(/\/+$/, "");
    if (!apiUrl.endsWith(this._apiVersionPrefix)) {
      apiUrl = `${apiUrl}/${this._apiVersionPrefix}`;
    }
    this._fetcher = this._initializeFetcher(config);
    this._config = config;
    this._apiUrl = apiUrl;
  }
  /**
   * Initializes the fetch function for HTTP requests.
   *
   * - Uses `config.fetcher` if provided.
   * - Falls back to global `fetch` if available.
   * - Throws an error if no fetch function is available.
   *
   * @param config - Configuration object that may include a custom fetch function.
   * @returns The fetch function to be used for HTTP requests.
   * @throws Error if no fetch function is available in the environment.
   */
  _initializeFetcher(config) {
    if (config.fetcher) {
      return config.fetcher;
    } else if (typeof globalThis?.fetch === "function") {
      return globalThis.fetch.bind(globalThis);
    } else {
      throw new Error(
        "Fetch API is not available in this environment. Please provide a fetch function in the config."
      );
    }
  }
  /**
   * Fetch the delegation chain from the Delegation Storage Service, ending with
   * the specified leaf delegation.
   *
   * @param leafDelegationOrDelegationHash - the leaf delegation, or the hash
   * of the leaf delegation
   * @returns resolves to the delegation chain - empty array if the delegation
   * is not found.
   */
  async getDelegationChain(leafDelegationOrDelegationHash) {
    const leafDelegationHash = typeof leafDelegationOrDelegationHash === "string" ? leafDelegationOrDelegationHash : getDelegationHashOffchain(leafDelegationOrDelegationHash);
    const response = await this._fetcher(
      `${this._apiUrl}/delegation/chain/${leafDelegationHash}`,
      {
        method: "GET",
        headers: {
          Authorization: `Bearer ${this._config.apiKey}`,
          "x-api-key-id": this._config.apiKeyId
        }
      }
    );
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(
        `Failed to fetch delegation chain: ${responseData.error}`
      );
    }
    return responseData.map((delegation) => ({
      ...delegation,
      salt: BigInt(delegation.salt)
    }));
  }
  /**
   * Fetch the delegations from the Delegation Storage Service, either `Received`
   * by, or `Given` by, (or both: `All`) the specified deleGatorAddress. Defaults
   * to `Received`
   *
   * @param deleGatorAddress - The deleGatorAddress to retrieve the delegations for.
   * @param filterMode - the DelegationStoreFilter mode - defaults to Received
   * @returns resolves to the list of delegations received by the deleGatorAddress, empty array if the delegations are not found.
   */
  async fetchDelegations(deleGatorAddress, filterMode = "RECEIVED" /* Received */) {
    const response = await this._fetcher(
      `${this._apiUrl}/delegation/accounts/${deleGatorAddress}?filter=${filterMode}`,
      {
        method: "GET",
        headers: {
          Authorization: `Bearer ${this._config.apiKey}`,
          "x-api-key-id": this._config.apiKeyId
        }
      }
    );
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(`Failed to fetch delegations: ${responseData.error}`);
    }
    return responseData.map((delegation) => ({
      ...delegation,
      salt: BigInt(delegation.salt)
    }));
  }
  /**
   * Store the specified delegation in the Delegation Storage Service.
   *
   * @param delegation - the delegation to store
   * @returns resolves to the delegation hash indicating successfully stored
   */
  async storeDelegation(delegation) {
    if (!delegation.signature || delegation.signature === "0x") {
      throw new Error("Delegation must be signed to be stored");
    }
    const delegationHash = getDelegationHashOffchain(delegation);
    const body = JSON.stringify(
      {
        ...delegation,
        metadata: []
      },
      (_, value) => typeof value === "bigint" || typeof value === "number" ? toHex13(value) : value,
      2
    );
    const response = await this._fetcher(`${this._apiUrl}/delegation/store`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this._config.apiKey}`,
        "x-api-key-id": this._config.apiKeyId,
        "Content-Type": "application/json"
      },
      body
    });
    const responseData = await response.json();
    if ("error" in responseData) {
      throw new Error(responseData.error);
    }
    if (responseData.delegationHash !== delegationHash) {
      throw Error(
        "Failed to store the Delegation, the hash returned from the MM delegation storage API does not match the hash of the delegation"
      );
    }
    return responseData.delegationHash;
  }
};

// src/executions.ts
import { encodeAbiParameters as encodeAbiParameters3, encodePacked as encodePacked6, zeroAddress } from "viem";
var createExecution = (target = zeroAddress, value = BigInt(0), callData = "0x") => ({
  target,
  value,
  callData
});
var SINGLE_DEFAULT_MODE = "0x0000000000000000000000000000000000000000000000000000000000000000";
var SINGLE_TRY_MODE = "0x0001000000000000000000000000000000000000000000000000000000000000";
var BATCH_DEFAULT_MODE = "0x0100000000000000000000000000000000000000000000000000000000000000";
var BATCH_TRY_MODE = "0x0101000000000000000000000000000000000000000000000000000000000000";
var EXECUTION_ABI_TYPE_COMPONENTS = [
  { type: "address", name: "target" },
  { type: "uint256", name: "value" },
  { type: "bytes", name: "callData" }
];
var encodeSingleExecution = (execution) => {
  return encodePacked6(
    ["address", "uint256", "bytes"],
    [execution.target, execution.value, execution.callData]
  );
};
var encodeBatchExecution = (executions) => {
  return encodeAbiParameters3(
    [
      {
        components: EXECUTION_ABI_TYPE_COMPONENTS,
        name: "executions",
        type: "tuple[]"
      }
    ],
    [executions]
  );
};
var encodeExecutionCalldata = (executions) => {
  if (executions.length == 0) {
    throw new Error(
      `Error while getting the execution calldatas, executions is empty`
    );
  }
  if (executions.length == 1) {
    const execution = executions[0];
    return encodeSingleExecution(execution);
  }
  return encodeBatchExecution(executions);
};
var encodeExecutionCalldatas = (executionsBatch) => {
  if (executionsBatch.length == 0) {
    throw new Error(
      `Error while getting the execution calldatas, executionsBatch is empty`
    );
  }
  return executionsBatch.map(encodeExecutionCalldata);
};

// src/blockchain.ts
import { CHAIN_ID } from "@metamask-private/delegation-deployments";
var getExplorerAddressLink = (chainId, address) => {
  const prefix = getExplorerLink(chainId);
  return `${prefix}/address/${address}`;
};
var getExplorerTransactionLink = (chainId, hash) => {
  const prefix = getExplorerLink(chainId);
  return `${prefix}/tx/${hash}`;
};
var CHAIN_EXPLORERS = {
  [CHAIN_ID.mainnet]: "https://etherscan.io",
  [CHAIN_ID.optimism]: "https://optimistic.etherscan.io",
  [CHAIN_ID.polygon]: "https://polygonscan.com",
  [CHAIN_ID.base]: "https://basescan.org",
  [CHAIN_ID.arbitrum]: "https://arbiscan.io",
  [CHAIN_ID.linea]: "https://lineascan.build",
  [CHAIN_ID.sepolia]: "https://sepolia.etherscan.io",
  [CHAIN_ID.lineaGoerli]: "https://goerli.lineascan.build",
  [CHAIN_ID.lineaSepolia]: "https://sepolia.lineascan.build"
};
var getExplorerLink = (chainId) => {
  const url = CHAIN_EXPLORERS[chainId];
  if (!url) {
    throw new Error(`Unsupported chainId: ${chainId}`);
  }
  return url;
};
var shortenHash = (address) => !!address ? address.slice(0, 6) + "..." : "";
var getInfuraRpcUrl = (chainId, apiKey) => {
  if (!apiKey)
    throw new Error("Infura API key is required");
  switch (chainId) {
    case CHAIN_ID.mainnet:
      return `https://mainnet.infura.io/v3/${apiKey}`;
    case CHAIN_ID.optimism:
      return `https://optimism-mainnet.infura.io/v3/${apiKey}`;
    case CHAIN_ID.polygon:
      return `https://polygon-mainnet.infura.io/v3/${apiKey}`;
    case CHAIN_ID.arbitrum:
      return `https://arbitrum-mainnet.infura.io/v3/${apiKey}`;
    case CHAIN_ID.linea:
      return `https://linea-mainnet.infura.io/v3/${apiKey}`;
    case CHAIN_ID.sepolia:
      return `https://sepolia.infura.io/v3/${apiKey}`;
    case CHAIN_ID.lineaSepolia:
      return `https://linea-sepolia.infura.io/v3/${apiKey}`;
    default:
      throw new Error(`Unsupported chainId: ${chainId}`);
  }
};

// src/constants.ts
var Implementation = /* @__PURE__ */ ((Implementation2) => {
  Implementation2[Implementation2["MultiSig"] = 0] = "MultiSig";
  Implementation2[Implementation2["Hybrid"] = 1] = "Hybrid";
  return Implementation2;
})(Implementation || {});

// src/data.ts
import { isHex as isHex6, toHex as toHex14 } from "viem";
function isEqualHex(a, b) {
  return isHex6(a) && a.toLowerCase() === b.toLowerCase();
}
function deepHexlify(obj) {
  if (typeof obj === "function") {
    return void 0;
  }
  if (obj == null || typeof obj === "string" || typeof obj === "boolean") {
    return obj;
  }
  if (typeof obj === "bigint") {
    return toHex14(obj);
  }
  if (obj._isBigNumber != null || typeof obj !== "object") {
    return toHex14(obj).replace(/^0x0/, "0x");
  }
  if (Array.isArray(obj)) {
    return obj.map((member) => deepHexlify(member));
  }
  return Object.keys(obj).reduce(
    (set, key) => Object.assign(Object.assign({}, set), {
      [key]: deepHexlify(obj[key])
    }),
    {}
  );
}

// src/delegatorEnvironment.ts
import { DELEGATOR_CONTRACTS } from "@metamask-private/delegation-deployments";
import {
  EntryPoint,
  SimpleFactory as SimpleFactory2,
  DelegationManager as DelegationManager2,
  MultiSigDeleGator,
  HybridDeleGator,
  SCL_RIP7212,
  AllowedTargetsEnforcer,
  AllowedMethodsEnforcer,
  DeployedEnforcer,
  TimestampEnforcer,
  NonceEnforcer,
  AllowedCalldataEnforcer,
  BlockNumberEnforcer,
  LimitedCallsEnforcer,
  ERC20BalanceGteEnforcer,
  IdEnforcer,
  ERC20TransferAmountEnforcer,
  ValueLteEnforcer,
  NativeTokenTransferAmountEnforcer,
  NativeBalanceGteEnforcer,
  NativeTokenPaymentEnforcer,
  RedeemerEnforcer,
  ArgsEqualityCheckEnforcer,
  ERC721BalanceGteEnforcer,
  ERC721TransferEnforcer,
  ERC1155BalanceGteEnforcer,
  OwnershipTransferEnforcer
} from "@metamask-private/delegation-abis";

// src/write.ts
import { SimpleFactory, DelegationManager } from "@metamask-private/delegation-abis";
var deployWithSimpleFactory = async (walletClient, publicClient, simpleFactoryAddress, creationCode, salt) => {
  const { request } = await publicClient.simulateContract({
    account: walletClient.account,
    address: simpleFactoryAddress,
    abi: SimpleFactory.abi,
    functionName: "deploy",
    args: [creationCode, salt.toString(16)]
  });
  return await walletClient.writeContract(request);
};
var redeemDelegations = async (walletClient, publicClient, delegationManagerAddress, redemptions) => {
  if (redemptions.length === 0) {
    throw new Error(`RedeemDelegations invalid zero redemptions`);
  }
  const permissionContexts = [];
  const executionsBatch = [];
  const executionModes = [];
  redemptions.forEach((redemption) => {
    permissionContexts.push(redemption.permissionContext);
    executionsBatch.push(redemption.executions);
    executionModes.push(redemption.mode);
  });
  const encodedPermissionContexts = encodePermissionContexts(permissionContexts);
  const executionCalldatas = encodeExecutionCalldatas(executionsBatch);
  const { request } = await publicClient.simulateContract({
    account: walletClient.account,
    address: delegationManagerAddress,
    abi: DelegationManager.abi,
    functionName: "redeemDelegations",
    args: [encodedPermissionContexts, executionModes, executionCalldatas]
  });
  return await walletClient.writeContract(request);
};
async function deployContract(walletClient, publicClient, chain, { bytecode, abi }, args = []) {
  const hash = await walletClient.deployContract({
    abi,
    bytecode,
    args,
    account: walletClient.account,
    chain
  });
  const receipt = await publicClient.waitForTransactionReceipt({
    hash
  });
  const address = (await receipt).contractAddress;
  return { address, hash, receipt };
}

// src/delegatorEnvironment.ts
var PREFERRED_VERSION = "1.2.0";
var contractOverrides = {
  "1.0.0": {},
  "1.1.0": {},
  "1.2.0": {}
};
function overrideDeployedEnvironment(chainId, version, environment) {
  contractOverrides[version][chainId] = environment;
}
function getDeleGatorEnvironment(chainId, version = PREFERRED_VERSION) {
  const override = contractOverrides[version][chainId];
  if (override) {
    return override;
  }
  const c = DELEGATOR_CONTRACTS[version]?.[chainId];
  if (!c) {
    throw new Error(
      `No contracts found for version ${version} chain ${chainId}`
    );
  }
  return getDeleGatorEnvironment_v1(c);
}
function getDeleGatorEnvironment_v1(c) {
  return {
    DelegationManager: c.DelegationManager,
    EntryPoint: c.EntryPoint,
    SimpleFactory: c.SimpleFactory,
    implementations: {
      MultiSigDeleGatorImpl: c.MultiSigDeleGatorImpl,
      HybridDeleGatorImpl: c.HybridDeleGatorImpl
    },
    caveatEnforcers: {
      AllowedCalldataEnforcer: c.AllowedCalldataEnforcer,
      AllowedMethodsEnforcer: c.AllowedMethodsEnforcer,
      AllowedTargetsEnforcer: c.AllowedTargetsEnforcer,
      ArgsEqualityCheckEnforcer: c.ArgsEqualityCheckEnforcer,
      BlockNumberEnforcer: c.BlockNumberEnforcer,
      DeployedEnforcer: c.DeployedEnforcer,
      ERC20BalanceGteEnforcer: c.ERC20BalanceGteEnforcer,
      ERC20TransferAmountEnforcer: c.ERC20TransferAmountEnforcer,
      ERC721BalanceGteEnforcer: c.ERC721BalanceGteEnforcer,
      ERC721TransferEnforcer: c.ERC721TransferEnforcer,
      ERC1155BalanceGteEnforcer: c.ERC1155BalanceGteEnforcer,
      IdEnforcer: c.IdEnforcer,
      LimitedCallsEnforcer: c.LimitedCallsEnforcer,
      NonceEnforcer: c.NonceEnforcer,
      TimestampEnforcer: c.TimestampEnforcer,
      ValueLteEnforcer: c.ValueLteEnforcer,
      NativeTokenTransferAmountEnforcer: c.NativeTokenTransferAmountEnforcer,
      NativeBalanceGteEnforcer: c.NativeBalanceGteEnforcer,
      NativeTokenPaymentEnforcer: c.NativeTokenPaymentEnforcer,
      OwnershipTransferEnforcer: c.OwnershipTransferEnforcer,
      RedeemerEnforcer: c.RedeemerEnforcer
    }
  };
}
async function deployDeleGatorEnvironment(walletClient, publicClient, chain, deployedContracts = {}) {
  const deployContractCurried = async (name, contract, params = []) => {
    if (deployedContracts[name]) {
      return {
        address: deployedContracts[name],
        name
      };
    }
    const deployedContract = await deployContract(
      walletClient,
      publicClient,
      chain,
      contract,
      params
    );
    deployedContracts[name] = deployedContract.address;
    return { ...deployedContract, name };
  };
  const standaloneContracts = {
    SimpleFactory: SimpleFactory2,
    AllowedCalldataEnforcer,
    AllowedTargetsEnforcer,
    AllowedMethodsEnforcer,
    ArgsEqualityCheckEnforcer,
    DeployedEnforcer,
    TimestampEnforcer,
    BlockNumberEnforcer,
    LimitedCallsEnforcer,
    ERC20BalanceGteEnforcer,
    ERC20TransferAmountEnforcer,
    ERC721BalanceGteEnforcer,
    ERC721TransferEnforcer,
    ERC1155BalanceGteEnforcer,
    IdEnforcer,
    NonceEnforcer,
    ValueLteEnforcer,
    NativeTokenTransferAmountEnforcer,
    NativeBalanceGteEnforcer,
    OwnershipTransferEnforcer,
    RedeemerEnforcer
  };
  for (const [name, contract] of Object.entries(standaloneContracts)) {
    await deployContractCurried(name, contract);
  }
  const delegationManager = await deployContractCurried(
    "DelegationManager",
    DelegationManager2,
    [walletClient.account?.address]
  );
  await deployContractCurried(
    "NativeTokenPaymentEnforcer",
    NativeTokenPaymentEnforcer,
    [delegationManager.address, deployedContracts["ArgsEqualityCheckEnforcer"]]
  );
  const entryPoint = await deployContractCurried("EntryPoint", EntryPoint);
  const { address: sclRIP7212 } = await deployContract(
    walletClient,
    publicClient,
    chain,
    SCL_RIP7212,
    []
  );
  const hybridDeleGatorWithLinkedLibrary = {
    ...HybridDeleGator,
    bytecode: HybridDeleGator.bytecode.replace(
      /__\$b8f96b288d4d0429e38b8ed50fd423070f\$__/g,
      sclRIP7212.slice(2)
    )
  };
  await deployContractCurried(
    "HybridDeleGatorImpl",
    hybridDeleGatorWithLinkedLibrary,
    [delegationManager.address, entryPoint.address]
  );
  await deployContractCurried("MultiSigDeleGatorImpl", MultiSigDeleGator, [
    delegationManager.address,
    entryPoint.address
  ]);
  return getDeleGatorEnvironment_v1(deployedContracts);
}

// src/rpcError.ts
var RpcError = class _RpcError extends Error {
  code;
  data;
  static INVALID_PARAMETERS = -32602;
  static INTERNAL_ERROR = -32603;
  static METHOD_NOT_SUPPORTED = -32601;
  // implementation-defined server-error
  static CONNECTION_CLOSED = -32001;
  static from(error) {
    if (error instanceof _RpcError) {
      return error;
    }
    const errorMessage = error instanceof Error ? error.message : error;
    return new _RpcError(errorMessage, _RpcError.INTERNAL_ERROR);
  }
  toJSONRPCError() {
    const { message, code, data } = this;
    return {
      message,
      code,
      data
    };
  }
  constructor(message, code, data) {
    super(message);
    Object.setPrototypeOf(this, _RpcError.prototype);
    this.code = code;
    this.data = data;
  }
};

// src/userOp.ts
import {
  encodeAbiParameters as encodeAbiParameters4,
  concat as concat13,
  toHex as toHex15,
  keccak256 as keccak2563,
  pad as pad4,
  getAddress
} from "viem";
var createRawUserOp = (sender, nonce2, callData, signature = "0x", options) => ({
  sender,
  nonce: nonce2,
  callData,
  factory: options?.factory,
  factoryData: options?.factoryData,
  callGasLimit: options?.callGasLimit ?? 0n,
  verificationGasLimit: options?.verificationGasLimit ?? 0n,
  preVerificationGas: options?.preVerificationGas ?? 0n,
  maxFeePerGas: options?.maxFeePerGas ?? 0n,
  maxPriorityFeePerGas: options?.maxPriorityFeePerGas ?? 0n,
  paymaster: options?.paymaster,
  paymasterVerificationGasLimit: options?.paymasterVerificationGasLimit,
  paymasterPostOpGasLimit: options?.paymasterPostOpGasLimit,
  paymasterData: options?.paymasterData,
  signature
});
var getSalt = (salt) => {
  if (!salt) {
    salt = "0x0";
  }
  return salt;
};
var getPaymasterAndData = (userOp) => {
  let paymasterAndData;
  if (userOp.paymaster) {
    paymasterAndData = concat13([
      userOp.paymaster,
      pad4(toHex15(userOp.paymasterVerificationGasLimit || 0n), {
        size: 16
      }),
      pad4(toHex15(userOp.paymasterPostOpGasLimit || 0n), {
        size: 16
      }),
      userOp.paymasterData || "0x"
    ]);
  } else {
    paymasterAndData = "0x";
  }
  return paymasterAndData;
};
var getInitCode = (userOp) => {
  return userOp.factory ? concat13([userOp.factory, userOp.factoryData ?? "0x"]) : "0x";
};
var getAccountGasLimits = (userOp) => {
  return concat13([
    pad4(toHex15(userOp.verificationGasLimit), {
      size: 16
    }),
    pad4(toHex15(userOp.callGasLimit), { size: 16 })
  ]);
};
var getGasFees = (userOp) => {
  return concat13([
    pad4(toHex15(userOp.maxPriorityFeePerGas), {
      size: 16
    }),
    pad4(toHex15(userOp.maxFeePerGas), { size: 16 })
  ]);
};
var packUserOp = (userOp) => {
  const packedOp = {
    sender: userOp.sender,
    nonce: BigInt(userOp.nonce),
    initCode: getInitCode(userOp),
    callData: userOp.callData,
    accountGasLimits: getAccountGasLimits(userOp),
    preVerificationGas: BigInt(userOp.preVerificationGas),
    gasFees: getGasFees(userOp),
    paymasterAndData: getPaymasterAndData(userOp),
    signature: userOp.signature
  };
  return packedOp;
};
var formatDelegationForSigning = (delegation) => {
  const caveats = delegation.caveats.map((caveat) => ({
    enforcer: getAddress(caveat.enforcer),
    terms: caveat.terms,
    args: caveat.args
  }));
  return {
    delegate: getAddress(delegation.delegate),
    delegator: getAddress(delegation.delegator),
    authority: delegation.authority === void 0 ? ROOT_AUTHORITY : delegation.authority,
    caveats,
    salt: delegation.salt
  };
};
var createUserOpHashV07 = (packedOp, entryPoint, chainId) => {
  const hash = keccak2563(
    encodeAbiParameters4(
      [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "nonce",
          type: "uint256"
        },
        {
          name: "initCodeHash",
          type: "bytes32"
        },
        {
          name: "callDataHash",
          type: "bytes32"
        },
        {
          name: "accountGasLimits",
          type: "bytes32"
        },
        {
          name: "preVerificationGas",
          type: "uint256"
        },
        {
          name: "gasFees",
          type: "bytes32"
        },
        {
          name: "paymasterAndDataHash",
          type: "bytes32"
        }
      ],
      [
        packedOp.sender,
        packedOp.nonce,
        keccak2563(packedOp.initCode),
        keccak2563(packedOp.callData),
        packedOp.accountGasLimits,
        packedOp.preVerificationGas,
        packedOp.gasFees,
        keccak2563(packedOp.paymasterAndData)
      ]
    )
  );
  return keccak2563(
    encodeAbiParameters4(
      [
        {
          name: "userOpHash",
          type: "bytes32"
        },
        {
          name: "entryPointAddress",
          type: "address"
        },
        {
          name: "chainId",
          type: "uint256"
        }
      ],
      [hash, entryPoint, chainId]
    )
  );
};
var SIGNABLE_USER_OP_TYPED_DATA = {
  PackedUserOperation: [
    { name: "sender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "initCode", type: "bytes" },
    { name: "callData", type: "bytes" },
    { name: "accountGasLimits", type: "bytes32" },
    { name: "preVerificationGas", type: "uint256" },
    { name: "gasFees", type: "bytes32" },
    { name: "paymasterAndData", type: "bytes" }
  ]
};

// src/webAuthn.ts
import { parseSignature } from "webauthn-p256";
import {
  parseAbiParameters as parseAbiParameters3,
  encodeAbiParameters as encodeAbiParameters5,
  encodePacked as encodePacked7,
  keccak256 as keccak2564,
  concat as concat14
} from "viem";
var FIELD_MODULUS = 115792089210356248762697446949407573529996955224135760342422259061068512044369n;
var MALLEABILITY_THRESHOLD = FIELD_MODULUS / 2n;
var SIGNATURE_ABI_PARAMS = parseAbiParameters3(
  "bytes32, uint256, uint256, bytes, bool, string, string, uint256"
);
var splitOnChallenge = (clientDataJson) => {
  try {
    const { challenge } = JSON.parse(clientDataJson);
    if (challenge === void 0) {
      throw new Error('No "challenge" found in the input string');
    }
    return clientDataJson.split(challenge);
  } catch (error) {
    throw new Error('No "challenge" found in the input string', {
      cause: error
    });
  }
};
var getResponseTypeLocation = (clientDataJson) => {
  try {
    const typeIndex = clientDataJson.indexOf('"type":');
    if (typeIndex === -1)
      throw new Error('No "type" found in the input string');
    return BigInt(typeIndex);
  } catch (error) {
    throw new Error('No "type" found in the input string', {
      cause: error
    });
  }
};
function encodeDeleGatorSignature(keyId, signature, clientDataJSON, authenticatorData) {
  const keyIdHash = keccak2564(encodePacked7(["string"], [keyId]));
  let { r, s } = parseSignature(signature);
  while (s > MALLEABILITY_THRESHOLD) {
    s = FIELD_MODULUS - s;
  }
  const [clientDataComponent1, clientDataComponent2] = splitOnChallenge(clientDataJSON);
  const { userVerified } = parseAuthenticatorFlags(authenticatorData);
  const responseTypeLocation = getResponseTypeLocation(clientDataJSON);
  const encodedSignature = encodeAbiParameters5(SIGNATURE_ABI_PARAMS, [
    keyIdHash,
    r,
    s,
    authenticatorData,
    userVerified,
    clientDataComponent1,
    clientDataComponent2,
    responseTypeLocation
  ]);
  return encodedSignature;
}
var AUTHENTICATOR_DATA_FLAGS_OFFSET = 32;
function parseAuthenticatorFlags(authenticatorData) {
  const authenticatorDataBuffer = Buffer.from(
    authenticatorData.slice(2),
    "hex"
  );
  const flags = authenticatorDataBuffer.readUInt8(
    AUTHENTICATOR_DATA_FLAGS_OFFSET
  );
  const bitMask = 1 << 2 /* USER_VERIFIED */;
  return {
    userVerified: (flags & bitMask) !== 0
  };
}
var createDummyWebAuthnSignature = (keyId) => {
  const rpIdHash = keccak2564(encodePacked7(["string"], ["AuthenticatorData"]));
  const flags = "0x05";
  const signCount = "0x00000000";
  const authenticatorData = concat14([rpIdHash, flags, signCount]);
  const keyIdHash = keccak2564(encodePacked7(["string"], [keyId]));
  const rs = 57896044605178124381348723474703786764998477612067880171211129530534256022184n;
  const userVerification = true;
  const clientDataPrefix = '{"type":"webauthn.get","challenge":"';
  const clientDataSuffix = '","origin":"passkey-domain","crossOrigin":false}';
  const responseTypeLocation = 1n;
  const encodedSignature = encodeAbiParameters5(SIGNATURE_ABI_PARAMS, [
    keyIdHash,
    rs,
    rs,
    authenticatorData,
    userVerification,
    clientDataPrefix,
    clientDataSuffix,
    responseTypeLocation
  ]);
  return encodedSignature;
};
export {
  ANY_BENEFICIARY,
  BATCH_DEFAULT_MODE,
  BATCH_TRY_MODE,
  CAVEAT_ABI_TYPE_COMPONENTS,
  CAVEAT_TYPEHASH,
  CaveatBuilder,
  DELEGATION_ABI_TYPE_COMPONENTS,
  DELEGATION_ARRAY_ABI_TYPE,
  DELEGATION_TYPEHASH,
  DelegationStorageClient,
  DelegationStorageEnvironment,
  DelegationStoreFilter,
  EXECUTION_ABI_TYPE_COMPONENTS,
  FIELD_MODULUS,
  Implementation,
  MALLEABILITY_THRESHOLD,
  PREFERRED_VERSION,
  ROOT_AUTHORITY,
  RpcError,
  SIGNABLE_DELEGATION_TYPED_DATA,
  SIGNABLE_USER_OP_TYPED_DATA,
  SIGNATURE_ABI_PARAMS,
  SINGLE_DEFAULT_MODE,
  SINGLE_TRY_MODE,
  createCaveat,
  createCaveatBuilder,
  createDelegation,
  createDummyWebAuthnSignature,
  createExecution,
  createOpenDelegation,
  createOpenRootDelegation,
  createRawUserOp,
  createRootDelegation,
  createUserOpHashV07,
  deepHexlify,
  deployContract,
  deployDeleGatorEnvironment,
  deployWithSimpleFactory,
  encodeBatchExecution,
  encodeDeleGatorSignature,
  encodeDelegation,
  encodeDelegations,
  encodeExecutionCalldata,
  encodeExecutionCalldatas,
  encodePermissionContexts,
  encodeSingleExecution,
  formatDelegationForSigning,
  getAccountGasLimits,
  getCaveatArrayPacketHash,
  getCaveatPacketHash,
  getDeleGatorEnvironment,
  getDeleGatorEnvironment_v1,
  getDelegationHashOffchain,
  getExplorerAddressLink,
  getExplorerTransactionLink,
  getGasFees,
  getInfuraRpcUrl,
  getInitCode,
  getPaymasterAndData,
  getResponseTypeLocation,
  getSalt,
  isEqualHex,
  overrideDeployedEnvironment,
  packUserOp,
  parseAuthenticatorFlags,
  prepDelegationHashForPasskeySign,
  redeemDelegations,
  resolveCaveats,
  shortenHash,
  signDelegation,
  splitOnChallenge
};
//# sourceMappingURL=index.mjs.map